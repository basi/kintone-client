<?php
/**
 * RECORDApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Kintone
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * REST API SPEC
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 20250423000000
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Kintone\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Kintone\ApiException;
use Kintone\Configuration;
use Kintone\FormDataProcessor;
use Kintone\HeaderSelector;
use Kintone\ObjectSerializer;

/**
 * RECORDApi Class Doc Comment
 *
 * @category Class
 * @package  Kintone
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class RECORDApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'deleteRecords' => [
            'application/json',
        ],
        'deleteRecordsForGuestSpace' => [
            'application/json',
        ],
        'postRecords' => [
            'application/json',
        ],
        'postRecordsForGuestSpace' => [
            'application/json',
        ],
        'putRecords' => [
            'application/json',
        ],
        'putRecordsForGuestSpace' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteRecords
     *
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecords'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteRecords($app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecords'][0])
    {
        list($response) = $this->deleteRecordsWithHttpInfo($app, $ids, $revisions, $contentType);
        return $response;
    }

    /**
     * Operation deleteRecordsWithHttpInfo
     *
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecords'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRecordsWithHttpInfo($app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecords'][0])
    {
        $request = $this->deleteRecordsRequest($app, $ids, $revisions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRecordsAsync
     *
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordsAsync($app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecords'][0])
    {
        return $this->deleteRecordsAsyncWithHttpInfo($app, $ids, $revisions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRecordsAsyncWithHttpInfo
     *
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordsAsyncWithHttpInfo($app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecords'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteRecordsRequest($app, $ids, $revisions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRecords'
     *
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRecordsRequest($app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecords'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling deleteRecords'
            );
        }

        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling deleteRecords'
            );
        }



        $resourcePath = '/k/v1/records.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $revisions,
            'revisions', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRecordsForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteRecordsForGuestSpace($guest_space_id, $app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecordsForGuestSpace'][0])
    {
        list($response) = $this->deleteRecordsForGuestSpaceWithHttpInfo($guest_space_id, $app, $ids, $revisions, $contentType);
        return $response;
    }

    /**
     * Operation deleteRecordsForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRecordsForGuestSpaceWithHttpInfo($guest_space_id, $app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecordsForGuestSpace'][0])
    {
        $request = $this->deleteRecordsForGuestSpaceRequest($guest_space_id, $app, $ids, $revisions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRecordsForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordsForGuestSpaceAsync($guest_space_id, $app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecordsForGuestSpace'][0])
    {
        return $this->deleteRecordsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $ids, $revisions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRecordsForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecordsForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteRecordsForGuestSpaceRequest($guest_space_id, $app, $ids, $revisions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRecordsForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The app ID. (required)
     * @param  int[] $ids Array of record IDs that will be deleted. Up to 100 records can be specified. (required)
     * @param  int[]|null $revisions The Expected revision number. The first id number will correspond to the first revision number in the array, the second id to the second revision number, and so on. If the revision number does not match, an error will occur and no records will be deleted. If the revision number is left blank or is -1, the revision number will not be checked for the corresponding record ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRecordsForGuestSpaceRequest($guest_space_id, $app, $ids, $revisions = null, string $contentType = self::contentTypes['deleteRecordsForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling deleteRecordsForGuestSpace'
            );
        }

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling deleteRecordsForGuestSpace'
            );
        }

        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling deleteRecordsForGuestSpace'
            );
        }



        $resourcePath = '/k/guest/{guestSpaceId}/v1/records.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $revisions,
            'revisions', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRecords
     *
     * @param  \Kintone\Model\PostRecordsRequest $post_records_request post_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecords'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostRecordsResponse
     */
    public function postRecords($post_records_request, string $contentType = self::contentTypes['postRecords'][0])
    {
        list($response) = $this->postRecordsWithHttpInfo($post_records_request, $contentType);
        return $response;
    }

    /**
     * Operation postRecordsWithHttpInfo
     *
     * @param  \Kintone\Model\PostRecordsRequest $post_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecords'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostRecordsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRecordsWithHttpInfo($post_records_request, string $contentType = self::contentTypes['postRecords'][0])
    {
        $request = $this->postRecordsRequest($post_records_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostRecordsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostRecordsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostRecordsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postRecordsAsync
     *
     * @param  \Kintone\Model\PostRecordsRequest $post_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordsAsync($post_records_request, string $contentType = self::contentTypes['postRecords'][0])
    {
        return $this->postRecordsAsyncWithHttpInfo($post_records_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRecordsAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PostRecordsRequest $post_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordsAsyncWithHttpInfo($post_records_request, string $contentType = self::contentTypes['postRecords'][0])
    {
        $returnType = '\Kintone\Model\PostRecordsResponse';
        $request = $this->postRecordsRequest($post_records_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRecords'
     *
     * @param  \Kintone\Model\PostRecordsRequest $post_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postRecordsRequest($post_records_request, string $contentType = self::contentTypes['postRecords'][0])
    {

        // verify the required parameter 'post_records_request' is set
        if ($post_records_request === null || (is_array($post_records_request) && count($post_records_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_records_request when calling postRecords'
            );
        }


        $resourcePath = '/k/v1/records.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_records_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_records_request));
            } else {
                $httpBody = $post_records_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRecordsForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsForGuestSpaceRequest $post_records_for_guest_space_request post_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostRecordsForGuestSpaceResponse
     */
    public function postRecordsForGuestSpace($guest_space_id, $post_records_for_guest_space_request, string $contentType = self::contentTypes['postRecordsForGuestSpace'][0])
    {
        list($response) = $this->postRecordsForGuestSpaceWithHttpInfo($guest_space_id, $post_records_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postRecordsForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsForGuestSpaceRequest $post_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostRecordsForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRecordsForGuestSpaceWithHttpInfo($guest_space_id, $post_records_for_guest_space_request, string $contentType = self::contentTypes['postRecordsForGuestSpace'][0])
    {
        $request = $this->postRecordsForGuestSpaceRequest($guest_space_id, $post_records_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostRecordsForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostRecordsForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostRecordsForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postRecordsForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsForGuestSpaceRequest $post_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordsForGuestSpaceAsync($guest_space_id, $post_records_for_guest_space_request, string $contentType = self::contentTypes['postRecordsForGuestSpace'][0])
    {
        return $this->postRecordsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_records_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRecordsForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsForGuestSpaceRequest $post_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_records_for_guest_space_request, string $contentType = self::contentTypes['postRecordsForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PostRecordsForGuestSpaceResponse';
        $request = $this->postRecordsForGuestSpaceRequest($guest_space_id, $post_records_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRecordsForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsForGuestSpaceRequest $post_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postRecordsForGuestSpaceRequest($guest_space_id, $post_records_for_guest_space_request, string $contentType = self::contentTypes['postRecordsForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling postRecordsForGuestSpace'
            );
        }

        // verify the required parameter 'post_records_for_guest_space_request' is set
        if ($post_records_for_guest_space_request === null || (is_array($post_records_for_guest_space_request) && count($post_records_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_records_for_guest_space_request when calling postRecordsForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/records.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_records_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_records_for_guest_space_request));
            } else {
                $httpBody = $post_records_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecords
     *
     * @param  \Kintone\Model\PutRecordsRequest $put_records_request put_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecords'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordsResponse
     */
    public function putRecords($put_records_request, string $contentType = self::contentTypes['putRecords'][0])
    {
        list($response) = $this->putRecordsWithHttpInfo($put_records_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordsWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordsRequest $put_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecords'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordsWithHttpInfo($put_records_request, string $contentType = self::contentTypes['putRecords'][0])
    {
        $request = $this->putRecordsRequest($put_records_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordsAsync
     *
     * @param  \Kintone\Model\PutRecordsRequest $put_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordsAsync($put_records_request, string $contentType = self::contentTypes['putRecords'][0])
    {
        return $this->putRecordsAsyncWithHttpInfo($put_records_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordsAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordsRequest $put_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordsAsyncWithHttpInfo($put_records_request, string $contentType = self::contentTypes['putRecords'][0])
    {
        $returnType = '\Kintone\Model\PutRecordsResponse';
        $request = $this->putRecordsRequest($put_records_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecords'
     *
     * @param  \Kintone\Model\PutRecordsRequest $put_records_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordsRequest($put_records_request, string $contentType = self::contentTypes['putRecords'][0])
    {

        // verify the required parameter 'put_records_request' is set
        if ($put_records_request === null || (is_array($put_records_request) && count($put_records_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_records_request when calling putRecords'
            );
        }


        $resourcePath = '/k/v1/records.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_records_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_records_request));
            } else {
                $httpBody = $put_records_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordsForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsForGuestSpaceRequest $put_records_for_guest_space_request put_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordsForGuestSpaceResponse
     */
    public function putRecordsForGuestSpace($guest_space_id, $put_records_for_guest_space_request, string $contentType = self::contentTypes['putRecordsForGuestSpace'][0])
    {
        list($response) = $this->putRecordsForGuestSpaceWithHttpInfo($guest_space_id, $put_records_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordsForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsForGuestSpaceRequest $put_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordsForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordsForGuestSpaceWithHttpInfo($guest_space_id, $put_records_for_guest_space_request, string $contentType = self::contentTypes['putRecordsForGuestSpace'][0])
    {
        $request = $this->putRecordsForGuestSpaceRequest($guest_space_id, $put_records_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordsForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordsForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordsForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordsForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsForGuestSpaceRequest $put_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordsForGuestSpaceAsync($guest_space_id, $put_records_for_guest_space_request, string $contentType = self::contentTypes['putRecordsForGuestSpace'][0])
    {
        return $this->putRecordsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_records_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordsForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsForGuestSpaceRequest $put_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_records_for_guest_space_request, string $contentType = self::contentTypes['putRecordsForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PutRecordsForGuestSpaceResponse';
        $request = $this->putRecordsForGuestSpaceRequest($guest_space_id, $put_records_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordsForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsForGuestSpaceRequest $put_records_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordsForGuestSpaceRequest($guest_space_id, $put_records_for_guest_space_request, string $contentType = self::contentTypes['putRecordsForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putRecordsForGuestSpace'
            );
        }

        // verify the required parameter 'put_records_for_guest_space_request' is set
        if ($put_records_for_guest_space_request === null || (is_array($put_records_for_guest_space_request) && count($put_records_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_records_for_guest_space_request when calling putRecordsForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/records.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_records_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_records_for_guest_space_request));
            } else {
                $httpBody = $put_records_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
