<?php
/**
 * SPACESApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Kintone
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * REST API SPEC
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 20250423000000
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Kintone\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Kintone\ApiException;
use Kintone\Configuration;
use Kintone\FormDataProcessor;
use Kintone\HeaderSelector;
use Kintone\ObjectSerializer;

/**
 * SPACESApi Class Doc Comment
 *
 * @category Class
 * @package  Kintone
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SPACESApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'deleteGuests' => [
            'application/json',
        ],
        'deleteGuestsForGuestSpace' => [
            'application/json',
        ],
        'deleteSpace' => [
            'application/json',
        ],
        'deleteSpaceForGuestSpace' => [
            'application/json',
        ],
        'getSpace' => [
            'application/json',
        ],
        'getSpaceForGuestSpace' => [
            'application/json',
        ],
        'getSpaceMembers' => [
            'application/json',
        ],
        'getSpaceMembersForGuestSpace' => [
            'application/json',
        ],
        'getSpacesStatistics' => [
            'application/json',
        ],
        'getSpacesStatisticsForGuestSpace' => [
            'application/json',
        ],
        'postGuests' => [
            'application/json',
        ],
        'postGuestsForGuestSpace' => [
            'application/json',
        ],
        'postSpaceThread' => [
            'application/json',
        ],
        'postSpaceThreadComment' => [
            'application/json',
        ],
        'postSpaceThreadCommentForGuestSpace' => [
            'application/json',
        ],
        'postSpaceThreadForGuestSpace' => [
            'application/json',
        ],
        'postTemplateSpace' => [
            'application/json',
        ],
        'postTemplateSpaceForGuestSpace' => [
            'application/json',
        ],
        'putSpace' => [
            'application/json',
        ],
        'putSpaceBody' => [
            'application/json',
        ],
        'putSpaceBodyForGuestSpace' => [
            'application/json',
        ],
        'putSpaceForGuestSpace' => [
            'application/json',
        ],
        'putSpaceGuests' => [
            'application/json',
        ],
        'putSpaceGuestsForGuestSpace' => [
            'application/json',
        ],
        'putSpaceMembers' => [
            'application/json',
        ],
        'putSpaceMembersForGuestSpace' => [
            'application/json',
        ],
        'putSpaceThread' => [
            'application/json',
        ],
        'putSpaceThreadForGuestSpace' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteGuests
     *
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuests'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteGuests($guests, string $contentType = self::contentTypes['deleteGuests'][0])
    {
        list($response) = $this->deleteGuestsWithHttpInfo($guests, $contentType);
        return $response;
    }

    /**
     * Operation deleteGuestsWithHttpInfo
     *
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuests'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuestsWithHttpInfo($guests, string $contentType = self::contentTypes['deleteGuests'][0])
    {
        $request = $this->deleteGuestsRequest($guests, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteGuestsAsync
     *
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGuestsAsync($guests, string $contentType = self::contentTypes['deleteGuests'][0])
    {
        return $this->deleteGuestsAsyncWithHttpInfo($guests, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuestsAsyncWithHttpInfo
     *
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGuestsAsyncWithHttpInfo($guests, string $contentType = self::contentTypes['deleteGuests'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteGuestsRequest($guests, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuests'
     *
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuestsRequest($guests, string $contentType = self::contentTypes['deleteGuests'][0])
    {

        // verify the required parameter 'guests' is set
        if ($guests === null || (is_array($guests) && count($guests) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guests when calling deleteGuests'
            );
        }


        $resourcePath = '/k/v1/guests.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $guests,
            'guests', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuestsForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteGuestsForGuestSpace($guest_space_id, $guests, string $contentType = self::contentTypes['deleteGuestsForGuestSpace'][0])
    {
        list($response) = $this->deleteGuestsForGuestSpaceWithHttpInfo($guest_space_id, $guests, $contentType);
        return $response;
    }

    /**
     * Operation deleteGuestsForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuestsForGuestSpaceWithHttpInfo($guest_space_id, $guests, string $contentType = self::contentTypes['deleteGuestsForGuestSpace'][0])
    {
        $request = $this->deleteGuestsForGuestSpaceRequest($guest_space_id, $guests, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteGuestsForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGuestsForGuestSpaceAsync($guest_space_id, $guests, string $contentType = self::contentTypes['deleteGuestsForGuestSpace'][0])
    {
        return $this->deleteGuestsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $guests, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuestsForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGuestsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $guests, string $contentType = self::contentTypes['deleteGuestsForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteGuestsForGuestSpaceRequest($guest_space_id, $guests, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuestsForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string[] $guests A list of email addresses of Guest users. Up to 100 Guests can be deleted. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuestsForGuestSpaceRequest($guest_space_id, $guests, string $contentType = self::contentTypes['deleteGuestsForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling deleteGuestsForGuestSpace'
            );
        }

        // verify the required parameter 'guests' is set
        if ($guests === null || (is_array($guests) && count($guests) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guests when calling deleteGuestsForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/guests.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $guests,
            'guests', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSpace
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteSpace($id, string $contentType = self::contentTypes['deleteSpace'][0])
    {
        list($response) = $this->deleteSpaceWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation deleteSpaceWithHttpInfo
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSpaceWithHttpInfo($id, string $contentType = self::contentTypes['deleteSpace'][0])
    {
        $request = $this->deleteSpaceRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteSpaceAsync
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSpaceAsync($id, string $contentType = self::contentTypes['deleteSpace'][0])
    {
        return $this->deleteSpaceAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSpaceAsyncWithHttpInfo
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSpaceAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteSpaceRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSpace'
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteSpaceRequest($id, string $contentType = self::contentTypes['deleteSpace'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteSpace'
            );
        }


        $resourcePath = '/k/v1/space.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSpaceForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteSpaceForGuestSpace($guest_space_id, $id, string $contentType = self::contentTypes['deleteSpaceForGuestSpace'][0])
    {
        list($response) = $this->deleteSpaceForGuestSpaceWithHttpInfo($guest_space_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation deleteSpaceForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSpaceForGuestSpaceWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['deleteSpaceForGuestSpace'][0])
    {
        $request = $this->deleteSpaceForGuestSpaceRequest($guest_space_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteSpaceForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSpaceForGuestSpaceAsync($guest_space_id, $id, string $contentType = self::contentTypes['deleteSpaceForGuestSpace'][0])
    {
        return $this->deleteSpaceForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSpaceForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSpaceForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['deleteSpaceForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteSpaceForGuestSpaceRequest($guest_space_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSpaceForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteSpaceForGuestSpaceRequest($guest_space_id, $id, string $contentType = self::contentTypes['deleteSpaceForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling deleteSpaceForGuestSpace'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteSpaceForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpace
     *
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetSpaceResponse
     */
    public function getSpace($id, string $contentType = self::contentTypes['getSpace'][0])
    {
        list($response) = $this->getSpaceWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getSpaceWithHttpInfo
     *
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpaceWithHttpInfo($id, string $contentType = self::contentTypes['getSpace'][0])
    {
        $request = $this->getSpaceRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSpaceAsync
     *
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceAsync($id, string $contentType = self::contentTypes['getSpace'][0])
    {
        return $this->getSpaceAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpaceAsyncWithHttpInfo
     *
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getSpace'][0])
    {
        $returnType = '\Kintone\Model\GetSpaceResponse';
        $request = $this->getSpaceRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpace'
     *
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSpaceRequest($id, string $contentType = self::contentTypes['getSpace'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSpace'
            );
        }


        $resourcePath = '/k/v1/space.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpaceForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetSpaceForGuestSpaceResponse
     */
    public function getSpaceForGuestSpace($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceForGuestSpace'][0])
    {
        list($response) = $this->getSpaceForGuestSpaceWithHttpInfo($guest_space_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation getSpaceForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetSpaceForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpaceForGuestSpaceWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceForGuestSpace'][0])
    {
        $request = $this->getSpaceForGuestSpaceRequest($guest_space_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetSpaceForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetSpaceForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetSpaceForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSpaceForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceForGuestSpaceAsync($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceForGuestSpace'][0])
    {
        return $this->getSpaceForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpaceForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetSpaceForGuestSpaceResponse';
        $request = $this->getSpaceForGuestSpaceRequest($guest_space_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpaceForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. The Space ID can be found in the URL of the Space. A Space with the URL of https://{domainname}.cybozu.com/k/#/space/111 has a Space ID of 111. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSpaceForGuestSpaceRequest($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getSpaceForGuestSpace'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSpaceForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpaceMembers
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembers'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetSpaceMembersResponse
     */
    public function getSpaceMembers($id, string $contentType = self::contentTypes['getSpaceMembers'][0])
    {
        list($response) = $this->getSpaceMembersWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getSpaceMembersWithHttpInfo
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembers'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetSpaceMembersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpaceMembersWithHttpInfo($id, string $contentType = self::contentTypes['getSpaceMembers'][0])
    {
        $request = $this->getSpaceMembersRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetSpaceMembersResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetSpaceMembersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetSpaceMembersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSpaceMembersAsync
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceMembersAsync($id, string $contentType = self::contentTypes['getSpaceMembers'][0])
    {
        return $this->getSpaceMembersAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpaceMembersAsyncWithHttpInfo
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceMembersAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getSpaceMembers'][0])
    {
        $returnType = '\Kintone\Model\GetSpaceMembersResponse';
        $request = $this->getSpaceMembersRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpaceMembers'
     *
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSpaceMembersRequest($id, string $contentType = self::contentTypes['getSpaceMembers'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSpaceMembers'
            );
        }


        $resourcePath = '/k/v1/space/members.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpaceMembersForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetSpaceMembersForGuestSpaceResponse
     */
    public function getSpaceMembersForGuestSpace($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceMembersForGuestSpace'][0])
    {
        list($response) = $this->getSpaceMembersForGuestSpaceWithHttpInfo($guest_space_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation getSpaceMembersForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetSpaceMembersForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpaceMembersForGuestSpaceWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceMembersForGuestSpace'][0])
    {
        $request = $this->getSpaceMembersForGuestSpaceRequest($guest_space_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetSpaceMembersForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetSpaceMembersForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetSpaceMembersForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSpaceMembersForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceMembersForGuestSpaceAsync($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceMembersForGuestSpace'][0])
    {
        return $this->getSpaceMembersForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpaceMembersForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceMembersForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceMembersForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetSpaceMembersForGuestSpaceResponse';
        $request = $this->getSpaceMembersForGuestSpaceRequest($guest_space_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpaceMembersForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $id The Space ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSpaceMembersForGuestSpaceRequest($guest_space_id, $id, string $contentType = self::contentTypes['getSpaceMembersForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getSpaceMembersForGuestSpace'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSpaceMembersForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space/members.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpacesStatistics
     *
     * @param  string|null $offset offset (optional)
     * @param  string|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatistics'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetSpacesStatisticsResponse
     */
    public function getSpacesStatistics($offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatistics'][0])
    {
        list($response) = $this->getSpacesStatisticsWithHttpInfo($offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getSpacesStatisticsWithHttpInfo
     *
     * @param  string|null $offset (optional)
     * @param  string|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatistics'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetSpacesStatisticsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpacesStatisticsWithHttpInfo($offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatistics'][0])
    {
        $request = $this->getSpacesStatisticsRequest($offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetSpacesStatisticsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetSpacesStatisticsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetSpacesStatisticsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSpacesStatisticsAsync
     *
     * @param  string|null $offset (optional)
     * @param  string|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpacesStatisticsAsync($offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatistics'][0])
    {
        return $this->getSpacesStatisticsAsyncWithHttpInfo($offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpacesStatisticsAsyncWithHttpInfo
     *
     * @param  string|null $offset (optional)
     * @param  string|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpacesStatisticsAsyncWithHttpInfo($offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatistics'][0])
    {
        $returnType = '\Kintone\Model\GetSpacesStatisticsResponse';
        $request = $this->getSpacesStatisticsRequest($offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpacesStatistics'
     *
     * @param  string|null $offset (optional)
     * @param  string|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSpacesStatisticsRequest($offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatistics'][0])
    {




        $resourcePath = '/k/v1/spaces/statistics.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpacesStatisticsForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string|null $offset offset (optional)
     * @param  string|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatisticsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetSpacesStatisticsForGuestSpaceResponse
     */
    public function getSpacesStatisticsForGuestSpace($guest_space_id, $offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatisticsForGuestSpace'][0])
    {
        list($response) = $this->getSpacesStatisticsForGuestSpaceWithHttpInfo($guest_space_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getSpacesStatisticsForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string|null $offset (optional)
     * @param  string|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatisticsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetSpacesStatisticsForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpacesStatisticsForGuestSpaceWithHttpInfo($guest_space_id, $offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatisticsForGuestSpace'][0])
    {
        $request = $this->getSpacesStatisticsForGuestSpaceRequest($guest_space_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetSpacesStatisticsForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetSpacesStatisticsForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetSpacesStatisticsForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSpacesStatisticsForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string|null $offset (optional)
     * @param  string|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatisticsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpacesStatisticsForGuestSpaceAsync($guest_space_id, $offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatisticsForGuestSpace'][0])
    {
        return $this->getSpacesStatisticsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpacesStatisticsForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string|null $offset (optional)
     * @param  string|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatisticsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpacesStatisticsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatisticsForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetSpacesStatisticsForGuestSpaceResponse';
        $request = $this->getSpacesStatisticsForGuestSpaceRequest($guest_space_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpacesStatisticsForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string|null $offset (optional)
     * @param  string|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpacesStatisticsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSpacesStatisticsForGuestSpaceRequest($guest_space_id, $offset = null, $limit = null, string $contentType = self::contentTypes['getSpacesStatisticsForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getSpacesStatisticsForGuestSpace'
            );
        }




        $resourcePath = '/k/guest/{guestSpaceId}/v1/spaces/statistics.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postGuests
     *
     * @param  \Kintone\Model\PostGuestsRequest $post_guests_request post_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuests'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function postGuests($post_guests_request, string $contentType = self::contentTypes['postGuests'][0])
    {
        list($response) = $this->postGuestsWithHttpInfo($post_guests_request, $contentType);
        return $response;
    }

    /**
     * Operation postGuestsWithHttpInfo
     *
     * @param  \Kintone\Model\PostGuestsRequest $post_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuests'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function postGuestsWithHttpInfo($post_guests_request, string $contentType = self::contentTypes['postGuests'][0])
    {
        $request = $this->postGuestsRequest($post_guests_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postGuestsAsync
     *
     * @param  \Kintone\Model\PostGuestsRequest $post_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postGuestsAsync($post_guests_request, string $contentType = self::contentTypes['postGuests'][0])
    {
        return $this->postGuestsAsyncWithHttpInfo($post_guests_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postGuestsAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PostGuestsRequest $post_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postGuestsAsyncWithHttpInfo($post_guests_request, string $contentType = self::contentTypes['postGuests'][0])
    {
        $returnType = 'mixed';
        $request = $this->postGuestsRequest($post_guests_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postGuests'
     *
     * @param  \Kintone\Model\PostGuestsRequest $post_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postGuestsRequest($post_guests_request, string $contentType = self::contentTypes['postGuests'][0])
    {

        // verify the required parameter 'post_guests_request' is set
        if ($post_guests_request === null || (is_array($post_guests_request) && count($post_guests_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_guests_request when calling postGuests'
            );
        }


        $resourcePath = '/k/v1/guests.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_guests_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_guests_request));
            } else {
                $httpBody = $post_guests_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postGuestsForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostGuestsForGuestSpaceRequest $post_guests_for_guest_space_request post_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function postGuestsForGuestSpace($guest_space_id, $post_guests_for_guest_space_request, string $contentType = self::contentTypes['postGuestsForGuestSpace'][0])
    {
        list($response) = $this->postGuestsForGuestSpaceWithHttpInfo($guest_space_id, $post_guests_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postGuestsForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostGuestsForGuestSpaceRequest $post_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function postGuestsForGuestSpaceWithHttpInfo($guest_space_id, $post_guests_for_guest_space_request, string $contentType = self::contentTypes['postGuestsForGuestSpace'][0])
    {
        $request = $this->postGuestsForGuestSpaceRequest($guest_space_id, $post_guests_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postGuestsForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostGuestsForGuestSpaceRequest $post_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postGuestsForGuestSpaceAsync($guest_space_id, $post_guests_for_guest_space_request, string $contentType = self::contentTypes['postGuestsForGuestSpace'][0])
    {
        return $this->postGuestsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_guests_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postGuestsForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostGuestsForGuestSpaceRequest $post_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postGuestsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_guests_for_guest_space_request, string $contentType = self::contentTypes['postGuestsForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->postGuestsForGuestSpaceRequest($guest_space_id, $post_guests_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postGuestsForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostGuestsForGuestSpaceRequest $post_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postGuestsForGuestSpaceRequest($guest_space_id, $post_guests_for_guest_space_request, string $contentType = self::contentTypes['postGuestsForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling postGuestsForGuestSpace'
            );
        }

        // verify the required parameter 'post_guests_for_guest_space_request' is set
        if ($post_guests_for_guest_space_request === null || (is_array($post_guests_for_guest_space_request) && count($post_guests_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_guests_for_guest_space_request when calling postGuestsForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/guests.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_guests_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_guests_for_guest_space_request));
            } else {
                $httpBody = $post_guests_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSpaceThread
     *
     * @param  \Kintone\Model\PostSpaceThreadRequest $post_space_thread_request post_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThread'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostSpaceThreadResponse
     */
    public function postSpaceThread($post_space_thread_request, string $contentType = self::contentTypes['postSpaceThread'][0])
    {
        list($response) = $this->postSpaceThreadWithHttpInfo($post_space_thread_request, $contentType);
        return $response;
    }

    /**
     * Operation postSpaceThreadWithHttpInfo
     *
     * @param  \Kintone\Model\PostSpaceThreadRequest $post_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThread'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostSpaceThreadResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSpaceThreadWithHttpInfo($post_space_thread_request, string $contentType = self::contentTypes['postSpaceThread'][0])
    {
        $request = $this->postSpaceThreadRequest($post_space_thread_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostSpaceThreadResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostSpaceThreadResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostSpaceThreadResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postSpaceThreadAsync
     *
     * @param  \Kintone\Model\PostSpaceThreadRequest $post_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThread'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpaceThreadAsync($post_space_thread_request, string $contentType = self::contentTypes['postSpaceThread'][0])
    {
        return $this->postSpaceThreadAsyncWithHttpInfo($post_space_thread_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSpaceThreadAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PostSpaceThreadRequest $post_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThread'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpaceThreadAsyncWithHttpInfo($post_space_thread_request, string $contentType = self::contentTypes['postSpaceThread'][0])
    {
        $returnType = '\Kintone\Model\PostSpaceThreadResponse';
        $request = $this->postSpaceThreadRequest($post_space_thread_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSpaceThread'
     *
     * @param  \Kintone\Model\PostSpaceThreadRequest $post_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThread'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postSpaceThreadRequest($post_space_thread_request, string $contentType = self::contentTypes['postSpaceThread'][0])
    {

        // verify the required parameter 'post_space_thread_request' is set
        if ($post_space_thread_request === null || (is_array($post_space_thread_request) && count($post_space_thread_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_space_thread_request when calling postSpaceThread'
            );
        }


        $resourcePath = '/k/v1/space/thread.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_space_thread_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_space_thread_request));
            } else {
                $httpBody = $post_space_thread_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSpaceThreadComment
     *
     * @param  \Kintone\Model\PostSpaceThreadCommentRequest $post_space_thread_comment_request post_space_thread_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadComment'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostSpaceThreadCommentResponse
     */
    public function postSpaceThreadComment($post_space_thread_comment_request, string $contentType = self::contentTypes['postSpaceThreadComment'][0])
    {
        list($response) = $this->postSpaceThreadCommentWithHttpInfo($post_space_thread_comment_request, $contentType);
        return $response;
    }

    /**
     * Operation postSpaceThreadCommentWithHttpInfo
     *
     * @param  \Kintone\Model\PostSpaceThreadCommentRequest $post_space_thread_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadComment'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostSpaceThreadCommentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSpaceThreadCommentWithHttpInfo($post_space_thread_comment_request, string $contentType = self::contentTypes['postSpaceThreadComment'][0])
    {
        $request = $this->postSpaceThreadCommentRequest($post_space_thread_comment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostSpaceThreadCommentResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostSpaceThreadCommentResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostSpaceThreadCommentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postSpaceThreadCommentAsync
     *
     * @param  \Kintone\Model\PostSpaceThreadCommentRequest $post_space_thread_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpaceThreadCommentAsync($post_space_thread_comment_request, string $contentType = self::contentTypes['postSpaceThreadComment'][0])
    {
        return $this->postSpaceThreadCommentAsyncWithHttpInfo($post_space_thread_comment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSpaceThreadCommentAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PostSpaceThreadCommentRequest $post_space_thread_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpaceThreadCommentAsyncWithHttpInfo($post_space_thread_comment_request, string $contentType = self::contentTypes['postSpaceThreadComment'][0])
    {
        $returnType = '\Kintone\Model\PostSpaceThreadCommentResponse';
        $request = $this->postSpaceThreadCommentRequest($post_space_thread_comment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSpaceThreadComment'
     *
     * @param  \Kintone\Model\PostSpaceThreadCommentRequest $post_space_thread_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postSpaceThreadCommentRequest($post_space_thread_comment_request, string $contentType = self::contentTypes['postSpaceThreadComment'][0])
    {

        // verify the required parameter 'post_space_thread_comment_request' is set
        if ($post_space_thread_comment_request === null || (is_array($post_space_thread_comment_request) && count($post_space_thread_comment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_space_thread_comment_request when calling postSpaceThreadComment'
            );
        }


        $resourcePath = '/k/v1/space/thread/comment.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_space_thread_comment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_space_thread_comment_request));
            } else {
                $httpBody = $post_space_thread_comment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSpaceThreadCommentForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadCommentForGuestSpaceRequest $post_space_thread_comment_for_guest_space_request post_space_thread_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostSpaceThreadCommentForGuestSpaceResponse
     */
    public function postSpaceThreadCommentForGuestSpace($guest_space_id, $post_space_thread_comment_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadCommentForGuestSpace'][0])
    {
        list($response) = $this->postSpaceThreadCommentForGuestSpaceWithHttpInfo($guest_space_id, $post_space_thread_comment_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postSpaceThreadCommentForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadCommentForGuestSpaceRequest $post_space_thread_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostSpaceThreadCommentForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSpaceThreadCommentForGuestSpaceWithHttpInfo($guest_space_id, $post_space_thread_comment_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadCommentForGuestSpace'][0])
    {
        $request = $this->postSpaceThreadCommentForGuestSpaceRequest($guest_space_id, $post_space_thread_comment_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostSpaceThreadCommentForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostSpaceThreadCommentForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostSpaceThreadCommentForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postSpaceThreadCommentForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadCommentForGuestSpaceRequest $post_space_thread_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpaceThreadCommentForGuestSpaceAsync($guest_space_id, $post_space_thread_comment_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadCommentForGuestSpace'][0])
    {
        return $this->postSpaceThreadCommentForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_space_thread_comment_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSpaceThreadCommentForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadCommentForGuestSpaceRequest $post_space_thread_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpaceThreadCommentForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_space_thread_comment_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadCommentForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PostSpaceThreadCommentForGuestSpaceResponse';
        $request = $this->postSpaceThreadCommentForGuestSpaceRequest($guest_space_id, $post_space_thread_comment_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSpaceThreadCommentForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadCommentForGuestSpaceRequest $post_space_thread_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postSpaceThreadCommentForGuestSpaceRequest($guest_space_id, $post_space_thread_comment_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadCommentForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling postSpaceThreadCommentForGuestSpace'
            );
        }

        // verify the required parameter 'post_space_thread_comment_for_guest_space_request' is set
        if ($post_space_thread_comment_for_guest_space_request === null || (is_array($post_space_thread_comment_for_guest_space_request) && count($post_space_thread_comment_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_space_thread_comment_for_guest_space_request when calling postSpaceThreadCommentForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space/thread/comment.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_space_thread_comment_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_space_thread_comment_for_guest_space_request));
            } else {
                $httpBody = $post_space_thread_comment_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSpaceThreadForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadForGuestSpaceRequest $post_space_thread_for_guest_space_request post_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostSpaceThreadForGuestSpaceResponse
     */
    public function postSpaceThreadForGuestSpace($guest_space_id, $post_space_thread_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadForGuestSpace'][0])
    {
        list($response) = $this->postSpaceThreadForGuestSpaceWithHttpInfo($guest_space_id, $post_space_thread_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postSpaceThreadForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadForGuestSpaceRequest $post_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostSpaceThreadForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSpaceThreadForGuestSpaceWithHttpInfo($guest_space_id, $post_space_thread_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadForGuestSpace'][0])
    {
        $request = $this->postSpaceThreadForGuestSpaceRequest($guest_space_id, $post_space_thread_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostSpaceThreadForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostSpaceThreadForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostSpaceThreadForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postSpaceThreadForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadForGuestSpaceRequest $post_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpaceThreadForGuestSpaceAsync($guest_space_id, $post_space_thread_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadForGuestSpace'][0])
    {
        return $this->postSpaceThreadForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_space_thread_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSpaceThreadForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadForGuestSpaceRequest $post_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSpaceThreadForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_space_thread_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PostSpaceThreadForGuestSpaceResponse';
        $request = $this->postSpaceThreadForGuestSpaceRequest($guest_space_id, $post_space_thread_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSpaceThreadForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostSpaceThreadForGuestSpaceRequest $post_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postSpaceThreadForGuestSpaceRequest($guest_space_id, $post_space_thread_for_guest_space_request, string $contentType = self::contentTypes['postSpaceThreadForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling postSpaceThreadForGuestSpace'
            );
        }

        // verify the required parameter 'post_space_thread_for_guest_space_request' is set
        if ($post_space_thread_for_guest_space_request === null || (is_array($post_space_thread_for_guest_space_request) && count($post_space_thread_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_space_thread_for_guest_space_request when calling postSpaceThreadForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space/thread.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_space_thread_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_space_thread_for_guest_space_request));
            } else {
                $httpBody = $post_space_thread_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTemplateSpace
     *
     * @param  \Kintone\Model\PostTemplateSpaceRequest $post_template_space_request post_template_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostTemplateSpaceResponse
     */
    public function postTemplateSpace($post_template_space_request, string $contentType = self::contentTypes['postTemplateSpace'][0])
    {
        list($response) = $this->postTemplateSpaceWithHttpInfo($post_template_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postTemplateSpaceWithHttpInfo
     *
     * @param  \Kintone\Model\PostTemplateSpaceRequest $post_template_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostTemplateSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTemplateSpaceWithHttpInfo($post_template_space_request, string $contentType = self::contentTypes['postTemplateSpace'][0])
    {
        $request = $this->postTemplateSpaceRequest($post_template_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostTemplateSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostTemplateSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostTemplateSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postTemplateSpaceAsync
     *
     * @param  \Kintone\Model\PostTemplateSpaceRequest $post_template_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTemplateSpaceAsync($post_template_space_request, string $contentType = self::contentTypes['postTemplateSpace'][0])
    {
        return $this->postTemplateSpaceAsyncWithHttpInfo($post_template_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTemplateSpaceAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PostTemplateSpaceRequest $post_template_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTemplateSpaceAsyncWithHttpInfo($post_template_space_request, string $contentType = self::contentTypes['postTemplateSpace'][0])
    {
        $returnType = '\Kintone\Model\PostTemplateSpaceResponse';
        $request = $this->postTemplateSpaceRequest($post_template_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTemplateSpace'
     *
     * @param  \Kintone\Model\PostTemplateSpaceRequest $post_template_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postTemplateSpaceRequest($post_template_space_request, string $contentType = self::contentTypes['postTemplateSpace'][0])
    {

        // verify the required parameter 'post_template_space_request' is set
        if ($post_template_space_request === null || (is_array($post_template_space_request) && count($post_template_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_template_space_request when calling postTemplateSpace'
            );
        }


        $resourcePath = '/k/v1/template/space.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_template_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_template_space_request));
            } else {
                $httpBody = $post_template_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTemplateSpaceForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostTemplateSpaceForGuestSpaceRequest $post_template_space_for_guest_space_request post_template_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostTemplateSpaceForGuestSpaceResponse
     */
    public function postTemplateSpaceForGuestSpace($guest_space_id, $post_template_space_for_guest_space_request, string $contentType = self::contentTypes['postTemplateSpaceForGuestSpace'][0])
    {
        list($response) = $this->postTemplateSpaceForGuestSpaceWithHttpInfo($guest_space_id, $post_template_space_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postTemplateSpaceForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostTemplateSpaceForGuestSpaceRequest $post_template_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostTemplateSpaceForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTemplateSpaceForGuestSpaceWithHttpInfo($guest_space_id, $post_template_space_for_guest_space_request, string $contentType = self::contentTypes['postTemplateSpaceForGuestSpace'][0])
    {
        $request = $this->postTemplateSpaceForGuestSpaceRequest($guest_space_id, $post_template_space_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostTemplateSpaceForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostTemplateSpaceForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostTemplateSpaceForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postTemplateSpaceForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostTemplateSpaceForGuestSpaceRequest $post_template_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTemplateSpaceForGuestSpaceAsync($guest_space_id, $post_template_space_for_guest_space_request, string $contentType = self::contentTypes['postTemplateSpaceForGuestSpace'][0])
    {
        return $this->postTemplateSpaceForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_template_space_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTemplateSpaceForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostTemplateSpaceForGuestSpaceRequest $post_template_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTemplateSpaceForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_template_space_for_guest_space_request, string $contentType = self::contentTypes['postTemplateSpaceForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PostTemplateSpaceForGuestSpaceResponse';
        $request = $this->postTemplateSpaceForGuestSpaceRequest($guest_space_id, $post_template_space_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTemplateSpaceForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostTemplateSpaceForGuestSpaceRequest $post_template_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postTemplateSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postTemplateSpaceForGuestSpaceRequest($guest_space_id, $post_template_space_for_guest_space_request, string $contentType = self::contentTypes['postTemplateSpaceForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling postTemplateSpaceForGuestSpace'
            );
        }

        // verify the required parameter 'post_template_space_for_guest_space_request' is set
        if ($post_template_space_for_guest_space_request === null || (is_array($post_template_space_for_guest_space_request) && count($post_template_space_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_template_space_for_guest_space_request when calling postTemplateSpaceForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/template/space.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_template_space_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_template_space_for_guest_space_request));
            } else {
                $httpBody = $post_template_space_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpace
     *
     * @param  \Kintone\Model\PutSpaceRequest $put_space_request put_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpace($put_space_request, string $contentType = self::contentTypes['putSpace'][0])
    {
        list($response) = $this->putSpaceWithHttpInfo($put_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceRequest $put_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceWithHttpInfo($put_space_request, string $contentType = self::contentTypes['putSpace'][0])
    {
        $request = $this->putSpaceRequest($put_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceAsync
     *
     * @param  \Kintone\Model\PutSpaceRequest $put_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceAsync($put_space_request, string $contentType = self::contentTypes['putSpace'][0])
    {
        return $this->putSpaceAsyncWithHttpInfo($put_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceRequest $put_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceAsyncWithHttpInfo($put_space_request, string $contentType = self::contentTypes['putSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceRequest($put_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpace'
     *
     * @param  \Kintone\Model\PutSpaceRequest $put_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceRequest($put_space_request, string $contentType = self::contentTypes['putSpace'][0])
    {

        // verify the required parameter 'put_space_request' is set
        if ($put_space_request === null || (is_array($put_space_request) && count($put_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_request when calling putSpace'
            );
        }


        $resourcePath = '/k/v1/space.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_request));
            } else {
                $httpBody = $put_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpaceBody
     *
     * @param  \Kintone\Model\PutSpaceBodyRequest $put_space_body_request put_space_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBody'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpaceBody($put_space_body_request, string $contentType = self::contentTypes['putSpaceBody'][0])
    {
        list($response) = $this->putSpaceBodyWithHttpInfo($put_space_body_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceBodyWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceBodyRequest $put_space_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBody'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceBodyWithHttpInfo($put_space_body_request, string $contentType = self::contentTypes['putSpaceBody'][0])
    {
        $request = $this->putSpaceBodyRequest($put_space_body_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceBodyAsync
     *
     * @param  \Kintone\Model\PutSpaceBodyRequest $put_space_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceBodyAsync($put_space_body_request, string $contentType = self::contentTypes['putSpaceBody'][0])
    {
        return $this->putSpaceBodyAsyncWithHttpInfo($put_space_body_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceBodyAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceBodyRequest $put_space_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceBodyAsyncWithHttpInfo($put_space_body_request, string $contentType = self::contentTypes['putSpaceBody'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceBodyRequest($put_space_body_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpaceBody'
     *
     * @param  \Kintone\Model\PutSpaceBodyRequest $put_space_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceBodyRequest($put_space_body_request, string $contentType = self::contentTypes['putSpaceBody'][0])
    {

        // verify the required parameter 'put_space_body_request' is set
        if ($put_space_body_request === null || (is_array($put_space_body_request) && count($put_space_body_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_body_request when calling putSpaceBody'
            );
        }


        $resourcePath = '/k/v1/space/body.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_body_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_body_request));
            } else {
                $httpBody = $put_space_body_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpaceBodyForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceBodyForGuestSpaceRequest $put_space_body_for_guest_space_request put_space_body_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBodyForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpaceBodyForGuestSpace($guest_space_id, $put_space_body_for_guest_space_request, string $contentType = self::contentTypes['putSpaceBodyForGuestSpace'][0])
    {
        list($response) = $this->putSpaceBodyForGuestSpaceWithHttpInfo($guest_space_id, $put_space_body_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceBodyForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceBodyForGuestSpaceRequest $put_space_body_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBodyForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceBodyForGuestSpaceWithHttpInfo($guest_space_id, $put_space_body_for_guest_space_request, string $contentType = self::contentTypes['putSpaceBodyForGuestSpace'][0])
    {
        $request = $this->putSpaceBodyForGuestSpaceRequest($guest_space_id, $put_space_body_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceBodyForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceBodyForGuestSpaceRequest $put_space_body_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBodyForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceBodyForGuestSpaceAsync($guest_space_id, $put_space_body_for_guest_space_request, string $contentType = self::contentTypes['putSpaceBodyForGuestSpace'][0])
    {
        return $this->putSpaceBodyForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_body_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceBodyForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceBodyForGuestSpaceRequest $put_space_body_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBodyForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceBodyForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_body_for_guest_space_request, string $contentType = self::contentTypes['putSpaceBodyForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceBodyForGuestSpaceRequest($guest_space_id, $put_space_body_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpaceBodyForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceBodyForGuestSpaceRequest $put_space_body_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceBodyForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceBodyForGuestSpaceRequest($guest_space_id, $put_space_body_for_guest_space_request, string $contentType = self::contentTypes['putSpaceBodyForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putSpaceBodyForGuestSpace'
            );
        }

        // verify the required parameter 'put_space_body_for_guest_space_request' is set
        if ($put_space_body_for_guest_space_request === null || (is_array($put_space_body_for_guest_space_request) && count($put_space_body_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_body_for_guest_space_request when calling putSpaceBodyForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space/body.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_body_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_body_for_guest_space_request));
            } else {
                $httpBody = $put_space_body_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpaceForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceForGuestSpaceRequest $put_space_for_guest_space_request put_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpaceForGuestSpace($guest_space_id, $put_space_for_guest_space_request, string $contentType = self::contentTypes['putSpaceForGuestSpace'][0])
    {
        list($response) = $this->putSpaceForGuestSpaceWithHttpInfo($guest_space_id, $put_space_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceForGuestSpaceRequest $put_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceForGuestSpaceWithHttpInfo($guest_space_id, $put_space_for_guest_space_request, string $contentType = self::contentTypes['putSpaceForGuestSpace'][0])
    {
        $request = $this->putSpaceForGuestSpaceRequest($guest_space_id, $put_space_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceForGuestSpaceRequest $put_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceForGuestSpaceAsync($guest_space_id, $put_space_for_guest_space_request, string $contentType = self::contentTypes['putSpaceForGuestSpace'][0])
    {
        return $this->putSpaceForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceForGuestSpaceRequest $put_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_for_guest_space_request, string $contentType = self::contentTypes['putSpaceForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceForGuestSpaceRequest($guest_space_id, $put_space_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpaceForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceForGuestSpaceRequest $put_space_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceForGuestSpaceRequest($guest_space_id, $put_space_for_guest_space_request, string $contentType = self::contentTypes['putSpaceForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putSpaceForGuestSpace'
            );
        }

        // verify the required parameter 'put_space_for_guest_space_request' is set
        if ($put_space_for_guest_space_request === null || (is_array($put_space_for_guest_space_request) && count($put_space_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_for_guest_space_request when calling putSpaceForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_for_guest_space_request));
            } else {
                $httpBody = $put_space_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpaceGuests
     *
     * @param  \Kintone\Model\PutSpaceGuestsRequest $put_space_guests_request put_space_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuests'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpaceGuests($put_space_guests_request, string $contentType = self::contentTypes['putSpaceGuests'][0])
    {
        list($response) = $this->putSpaceGuestsWithHttpInfo($put_space_guests_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceGuestsWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceGuestsRequest $put_space_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuests'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceGuestsWithHttpInfo($put_space_guests_request, string $contentType = self::contentTypes['putSpaceGuests'][0])
    {
        $request = $this->putSpaceGuestsRequest($put_space_guests_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceGuestsAsync
     *
     * @param  \Kintone\Model\PutSpaceGuestsRequest $put_space_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceGuestsAsync($put_space_guests_request, string $contentType = self::contentTypes['putSpaceGuests'][0])
    {
        return $this->putSpaceGuestsAsyncWithHttpInfo($put_space_guests_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceGuestsAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceGuestsRequest $put_space_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceGuestsAsyncWithHttpInfo($put_space_guests_request, string $contentType = self::contentTypes['putSpaceGuests'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceGuestsRequest($put_space_guests_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpaceGuests'
     *
     * @param  \Kintone\Model\PutSpaceGuestsRequest $put_space_guests_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceGuestsRequest($put_space_guests_request, string $contentType = self::contentTypes['putSpaceGuests'][0])
    {

        // verify the required parameter 'put_space_guests_request' is set
        if ($put_space_guests_request === null || (is_array($put_space_guests_request) && count($put_space_guests_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_guests_request when calling putSpaceGuests'
            );
        }


        $resourcePath = '/k/v1/space/guests.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_guests_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_guests_request));
            } else {
                $httpBody = $put_space_guests_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpaceGuestsForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceGuestsForGuestSpaceRequest $put_space_guests_for_guest_space_request put_space_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpaceGuestsForGuestSpace($guest_space_id, $put_space_guests_for_guest_space_request, string $contentType = self::contentTypes['putSpaceGuestsForGuestSpace'][0])
    {
        list($response) = $this->putSpaceGuestsForGuestSpaceWithHttpInfo($guest_space_id, $put_space_guests_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceGuestsForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceGuestsForGuestSpaceRequest $put_space_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceGuestsForGuestSpaceWithHttpInfo($guest_space_id, $put_space_guests_for_guest_space_request, string $contentType = self::contentTypes['putSpaceGuestsForGuestSpace'][0])
    {
        $request = $this->putSpaceGuestsForGuestSpaceRequest($guest_space_id, $put_space_guests_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceGuestsForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceGuestsForGuestSpaceRequest $put_space_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceGuestsForGuestSpaceAsync($guest_space_id, $put_space_guests_for_guest_space_request, string $contentType = self::contentTypes['putSpaceGuestsForGuestSpace'][0])
    {
        return $this->putSpaceGuestsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_guests_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceGuestsForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceGuestsForGuestSpaceRequest $put_space_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceGuestsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_guests_for_guest_space_request, string $contentType = self::contentTypes['putSpaceGuestsForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceGuestsForGuestSpaceRequest($guest_space_id, $put_space_guests_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpaceGuestsForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceGuestsForGuestSpaceRequest $put_space_guests_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceGuestsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceGuestsForGuestSpaceRequest($guest_space_id, $put_space_guests_for_guest_space_request, string $contentType = self::contentTypes['putSpaceGuestsForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putSpaceGuestsForGuestSpace'
            );
        }

        // verify the required parameter 'put_space_guests_for_guest_space_request' is set
        if ($put_space_guests_for_guest_space_request === null || (is_array($put_space_guests_for_guest_space_request) && count($put_space_guests_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_guests_for_guest_space_request when calling putSpaceGuestsForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space/guests.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_guests_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_guests_for_guest_space_request));
            } else {
                $httpBody = $put_space_guests_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpaceMembers
     *
     * @param  \Kintone\Model\PutSpaceMembersRequest $put_space_members_request put_space_members_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembers'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpaceMembers($put_space_members_request, string $contentType = self::contentTypes['putSpaceMembers'][0])
    {
        list($response) = $this->putSpaceMembersWithHttpInfo($put_space_members_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceMembersWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceMembersRequest $put_space_members_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembers'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceMembersWithHttpInfo($put_space_members_request, string $contentType = self::contentTypes['putSpaceMembers'][0])
    {
        $request = $this->putSpaceMembersRequest($put_space_members_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceMembersAsync
     *
     * @param  \Kintone\Model\PutSpaceMembersRequest $put_space_members_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceMembersAsync($put_space_members_request, string $contentType = self::contentTypes['putSpaceMembers'][0])
    {
        return $this->putSpaceMembersAsyncWithHttpInfo($put_space_members_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceMembersAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceMembersRequest $put_space_members_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceMembersAsyncWithHttpInfo($put_space_members_request, string $contentType = self::contentTypes['putSpaceMembers'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceMembersRequest($put_space_members_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpaceMembers'
     *
     * @param  \Kintone\Model\PutSpaceMembersRequest $put_space_members_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceMembersRequest($put_space_members_request, string $contentType = self::contentTypes['putSpaceMembers'][0])
    {

        // verify the required parameter 'put_space_members_request' is set
        if ($put_space_members_request === null || (is_array($put_space_members_request) && count($put_space_members_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_members_request when calling putSpaceMembers'
            );
        }


        $resourcePath = '/k/v1/space/members.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_members_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_members_request));
            } else {
                $httpBody = $put_space_members_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpaceMembersForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceMembersForGuestSpaceRequest $put_space_members_for_guest_space_request put_space_members_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpaceMembersForGuestSpace($guest_space_id, $put_space_members_for_guest_space_request, string $contentType = self::contentTypes['putSpaceMembersForGuestSpace'][0])
    {
        list($response) = $this->putSpaceMembersForGuestSpaceWithHttpInfo($guest_space_id, $put_space_members_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceMembersForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceMembersForGuestSpaceRequest $put_space_members_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceMembersForGuestSpaceWithHttpInfo($guest_space_id, $put_space_members_for_guest_space_request, string $contentType = self::contentTypes['putSpaceMembersForGuestSpace'][0])
    {
        $request = $this->putSpaceMembersForGuestSpaceRequest($guest_space_id, $put_space_members_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceMembersForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceMembersForGuestSpaceRequest $put_space_members_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceMembersForGuestSpaceAsync($guest_space_id, $put_space_members_for_guest_space_request, string $contentType = self::contentTypes['putSpaceMembersForGuestSpace'][0])
    {
        return $this->putSpaceMembersForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_members_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceMembersForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceMembersForGuestSpaceRequest $put_space_members_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceMembersForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_members_for_guest_space_request, string $contentType = self::contentTypes['putSpaceMembersForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceMembersForGuestSpaceRequest($guest_space_id, $put_space_members_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpaceMembersForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceMembersForGuestSpaceRequest $put_space_members_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceMembersForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceMembersForGuestSpaceRequest($guest_space_id, $put_space_members_for_guest_space_request, string $contentType = self::contentTypes['putSpaceMembersForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putSpaceMembersForGuestSpace'
            );
        }

        // verify the required parameter 'put_space_members_for_guest_space_request' is set
        if ($put_space_members_for_guest_space_request === null || (is_array($put_space_members_for_guest_space_request) && count($put_space_members_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_members_for_guest_space_request when calling putSpaceMembersForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space/members.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_members_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_members_for_guest_space_request));
            } else {
                $httpBody = $put_space_members_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpaceThread
     *
     * @param  \Kintone\Model\PutSpaceThreadRequest $put_space_thread_request put_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThread'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpaceThread($put_space_thread_request, string $contentType = self::contentTypes['putSpaceThread'][0])
    {
        list($response) = $this->putSpaceThreadWithHttpInfo($put_space_thread_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceThreadWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceThreadRequest $put_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThread'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceThreadWithHttpInfo($put_space_thread_request, string $contentType = self::contentTypes['putSpaceThread'][0])
    {
        $request = $this->putSpaceThreadRequest($put_space_thread_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceThreadAsync
     *
     * @param  \Kintone\Model\PutSpaceThreadRequest $put_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThread'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceThreadAsync($put_space_thread_request, string $contentType = self::contentTypes['putSpaceThread'][0])
    {
        return $this->putSpaceThreadAsyncWithHttpInfo($put_space_thread_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceThreadAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutSpaceThreadRequest $put_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThread'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceThreadAsyncWithHttpInfo($put_space_thread_request, string $contentType = self::contentTypes['putSpaceThread'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceThreadRequest($put_space_thread_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpaceThread'
     *
     * @param  \Kintone\Model\PutSpaceThreadRequest $put_space_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThread'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceThreadRequest($put_space_thread_request, string $contentType = self::contentTypes['putSpaceThread'][0])
    {

        // verify the required parameter 'put_space_thread_request' is set
        if ($put_space_thread_request === null || (is_array($put_space_thread_request) && count($put_space_thread_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_thread_request when calling putSpaceThread'
            );
        }


        $resourcePath = '/k/v1/space/thread.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_thread_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_thread_request));
            } else {
                $httpBody = $put_space_thread_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSpaceThreadForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceThreadForGuestSpaceRequest $put_space_thread_for_guest_space_request put_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function putSpaceThreadForGuestSpace($guest_space_id, $put_space_thread_for_guest_space_request, string $contentType = self::contentTypes['putSpaceThreadForGuestSpace'][0])
    {
        list($response) = $this->putSpaceThreadForGuestSpaceWithHttpInfo($guest_space_id, $put_space_thread_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putSpaceThreadForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceThreadForGuestSpaceRequest $put_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSpaceThreadForGuestSpaceWithHttpInfo($guest_space_id, $put_space_thread_for_guest_space_request, string $contentType = self::contentTypes['putSpaceThreadForGuestSpace'][0])
    {
        $request = $this->putSpaceThreadForGuestSpaceRequest($guest_space_id, $put_space_thread_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putSpaceThreadForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceThreadForGuestSpaceRequest $put_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceThreadForGuestSpaceAsync($guest_space_id, $put_space_thread_for_guest_space_request, string $contentType = self::contentTypes['putSpaceThreadForGuestSpace'][0])
    {
        return $this->putSpaceThreadForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_thread_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSpaceThreadForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceThreadForGuestSpaceRequest $put_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSpaceThreadForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_space_thread_for_guest_space_request, string $contentType = self::contentTypes['putSpaceThreadForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->putSpaceThreadForGuestSpaceRequest($guest_space_id, $put_space_thread_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSpaceThreadForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutSpaceThreadForGuestSpaceRequest $put_space_thread_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSpaceThreadForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSpaceThreadForGuestSpaceRequest($guest_space_id, $put_space_thread_for_guest_space_request, string $contentType = self::contentTypes['putSpaceThreadForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putSpaceThreadForGuestSpace'
            );
        }

        // verify the required parameter 'put_space_thread_for_guest_space_request' is set
        if ($put_space_thread_for_guest_space_request === null || (is_array($put_space_thread_for_guest_space_request) && count($put_space_thread_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_space_thread_for_guest_space_request when calling putSpaceThreadForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/space/thread.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_space_thread_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_space_thread_for_guest_space_request));
            } else {
                $httpBody = $put_space_thread_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
