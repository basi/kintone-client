<?php
/**
 * RECORDSApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Kintone
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * REST API SPEC
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 20250423000000
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Kintone\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Kintone\ApiException;
use Kintone\Configuration;
use Kintone\FormDataProcessor;
use Kintone\HeaderSelector;
use Kintone\ObjectSerializer;

/**
 * RECORDSApi Class Doc Comment
 *
 * @category Class
 * @package  Kintone
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class RECORDSApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'deleteRecordComment' => [
            'application/json',
        ],
        'deleteRecordCommentForGuestSpace' => [
            'application/json',
        ],
        'deleteRecordsCursor' => [
            'application/json',
        ],
        'deleteRecordsCursorForGuestSpace' => [
            'application/json',
        ],
        'getPreviewRecordAcl' => [
            'application/json',
        ],
        'getPreviewRecordAclForGuestSpace' => [
            'application/json',
        ],
        'getRecord' => [
            'application/json',
        ],
        'getRecordAcl' => [
            'application/json',
        ],
        'getRecordAclForGuestSpace' => [
            'application/json',
        ],
        'getRecordComments' => [
            'application/json',
        ],
        'getRecordCommentsForGuestSpace' => [
            'application/json',
        ],
        'getRecordForGuestSpace' => [
            'application/json',
        ],
        'getRecords' => [
            'application/json',
        ],
        'getRecordsAclEvaluate' => [
            'application/json',
        ],
        'getRecordsAclEvaluateForGuestSpace' => [
            'application/json',
        ],
        'getRecordsCursor' => [
            'application/json',
        ],
        'getRecordsCursorForGuestSpace' => [
            'application/json',
        ],
        'getRecordsForGuestSpace' => [
            'application/json',
        ],
        'postBulkRequest' => [
            'application/json',
        ],
        'postBulkRequestForGuestSpace' => [
            'application/json',
        ],
        'postRecord' => [
            'application/json',
        ],
        'postRecordComment' => [
            'application/json',
        ],
        'postRecordCommentForGuestSpace' => [
            'application/json',
        ],
        'postRecordForGuestSpace' => [
            'application/json',
        ],
        'postRecordsCursor' => [
            'application/json',
        ],
        'postRecordsCursorForGuestSpace' => [
            'application/json',
        ],
        'putPreviewRecordAcl' => [
            'application/json',
        ],
        'putPreviewRecordAclForGuestSpace' => [
            'application/json',
        ],
        'putRecord' => [
            'application/json',
        ],
        'putRecordAcl' => [
            'application/json',
        ],
        'putRecordAclForGuestSpace' => [
            'application/json',
        ],
        'putRecordAssignees' => [
            'application/json',
        ],
        'putRecordAssigneesForGuestSpace' => [
            'application/json',
        ],
        'putRecordForGuestSpace' => [
            'application/json',
        ],
        'putRecordStatus' => [
            'application/json',
        ],
        'putRecordStatusForGuestSpace' => [
            'application/json',
        ],
        'putRecordsStatus' => [
            'application/json',
        ],
        'putRecordsStatusForGuestSpace' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteRecordComment
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordComment'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteRecordComment($app, $record, $comment, string $contentType = self::contentTypes['deleteRecordComment'][0])
    {
        list($response) = $this->deleteRecordCommentWithHttpInfo($app, $record, $comment, $contentType);
        return $response;
    }

    /**
     * Operation deleteRecordCommentWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordComment'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRecordCommentWithHttpInfo($app, $record, $comment, string $contentType = self::contentTypes['deleteRecordComment'][0])
    {
        $request = $this->deleteRecordCommentRequest($app, $record, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRecordCommentAsync
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordCommentAsync($app, $record, $comment, string $contentType = self::contentTypes['deleteRecordComment'][0])
    {
        return $this->deleteRecordCommentAsyncWithHttpInfo($app, $record, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRecordCommentAsyncWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordCommentAsyncWithHttpInfo($app, $record, $comment, string $contentType = self::contentTypes['deleteRecordComment'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteRecordCommentRequest($app, $record, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRecordComment'
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRecordCommentRequest($app, $record, $comment, string $contentType = self::contentTypes['deleteRecordComment'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling deleteRecordComment'
            );
        }

        // verify the required parameter 'record' is set
        if ($record === null || (is_array($record) && count($record) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $record when calling deleteRecordComment'
            );
        }

        // verify the required parameter 'comment' is set
        if ($comment === null || (is_array($comment) && count($comment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment when calling deleteRecordComment'
            );
        }


        $resourcePath = '/k/v1/record/comment.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $record,
            'record', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRecordCommentForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteRecordCommentForGuestSpace($guest_space_id, $app, $record, $comment, string $contentType = self::contentTypes['deleteRecordCommentForGuestSpace'][0])
    {
        list($response) = $this->deleteRecordCommentForGuestSpaceWithHttpInfo($guest_space_id, $app, $record, $comment, $contentType);
        return $response;
    }

    /**
     * Operation deleteRecordCommentForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRecordCommentForGuestSpaceWithHttpInfo($guest_space_id, $app, $record, $comment, string $contentType = self::contentTypes['deleteRecordCommentForGuestSpace'][0])
    {
        $request = $this->deleteRecordCommentForGuestSpaceRequest($guest_space_id, $app, $record, $comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRecordCommentForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordCommentForGuestSpaceAsync($guest_space_id, $app, $record, $comment, string $contentType = self::contentTypes['deleteRecordCommentForGuestSpace'][0])
    {
        return $this->deleteRecordCommentForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $record, $comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRecordCommentForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordCommentForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $record, $comment, string $contentType = self::contentTypes['deleteRecordCommentForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteRecordCommentForGuestSpaceRequest($guest_space_id, $app, $record, $comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRecordCommentForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int $comment The Comment ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRecordCommentForGuestSpaceRequest($guest_space_id, $app, $record, $comment, string $contentType = self::contentTypes['deleteRecordCommentForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling deleteRecordCommentForGuestSpace'
            );
        }

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling deleteRecordCommentForGuestSpace'
            );
        }

        // verify the required parameter 'record' is set
        if ($record === null || (is_array($record) && count($record) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $record when calling deleteRecordCommentForGuestSpace'
            );
        }

        // verify the required parameter 'comment' is set
        if ($comment === null || (is_array($comment) && count($comment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment when calling deleteRecordCommentForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/record/comment.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $record,
            'record', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRecordsCursor
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursor'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteRecordsCursor($id, string $contentType = self::contentTypes['deleteRecordsCursor'][0])
    {
        list($response) = $this->deleteRecordsCursorWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation deleteRecordsCursorWithHttpInfo
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursor'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRecordsCursorWithHttpInfo($id, string $contentType = self::contentTypes['deleteRecordsCursor'][0])
    {
        $request = $this->deleteRecordsCursorRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRecordsCursorAsync
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordsCursorAsync($id, string $contentType = self::contentTypes['deleteRecordsCursor'][0])
    {
        return $this->deleteRecordsCursorAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRecordsCursorAsyncWithHttpInfo
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordsCursorAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteRecordsCursor'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteRecordsCursorRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRecordsCursor'
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRecordsCursorRequest($id, string $contentType = self::contentTypes['deleteRecordsCursor'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRecordsCursor'
            );
        }


        $resourcePath = '/k/v1/records/cursor.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRecordsCursorForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return mixed
     */
    public function deleteRecordsCursorForGuestSpace($guest_space_id, $id, string $contentType = self::contentTypes['deleteRecordsCursorForGuestSpace'][0])
    {
        list($response) = $this->deleteRecordsCursorForGuestSpaceWithHttpInfo($guest_space_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation deleteRecordsCursorForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of mixed, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRecordsCursorForGuestSpaceWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['deleteRecordsCursorForGuestSpace'][0])
    {
        $request = $this->deleteRecordsCursorForGuestSpaceRequest($guest_space_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'mixed',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'mixed',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRecordsCursorForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordsCursorForGuestSpaceAsync($guest_space_id, $id, string $contentType = self::contentTypes['deleteRecordsCursorForGuestSpace'][0])
    {
        return $this->deleteRecordsCursorForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRecordsCursorForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordsCursorForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['deleteRecordsCursorForGuestSpace'][0])
    {
        $returnType = 'mixed';
        $request = $this->deleteRecordsCursorForGuestSpaceRequest($guest_space_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRecordsCursorForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRecordsCursorForGuestSpaceRequest($guest_space_id, $id, string $contentType = self::contentTypes['deleteRecordsCursorForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling deleteRecordsCursorForGuestSpace'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRecordsCursorForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/records/cursor.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPreviewRecordAcl
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetPreviewRecordAclResponse
     */
    public function getPreviewRecordAcl($app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAcl'][0])
    {
        list($response) = $this->getPreviewRecordAclWithHttpInfo($app, $lang, $contentType);
        return $response;
    }

    /**
     * Operation getPreviewRecordAclWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetPreviewRecordAclResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPreviewRecordAclWithHttpInfo($app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAcl'][0])
    {
        $request = $this->getPreviewRecordAclRequest($app, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetPreviewRecordAclResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetPreviewRecordAclResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetPreviewRecordAclResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPreviewRecordAclAsync
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreviewRecordAclAsync($app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAcl'][0])
    {
        return $this->getPreviewRecordAclAsyncWithHttpInfo($app, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPreviewRecordAclAsyncWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreviewRecordAclAsyncWithHttpInfo($app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAcl'][0])
    {
        $returnType = '\Kintone\Model\GetPreviewRecordAclResponse';
        $request = $this->getPreviewRecordAclRequest($app, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPreviewRecordAcl'
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPreviewRecordAclRequest($app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAcl'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getPreviewRecordAcl'
            );
        }



        $resourcePath = '/k/v1/preview/record/acl.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPreviewRecordAclForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetPreviewRecordAclForGuestSpaceResponse
     */
    public function getPreviewRecordAclForGuestSpace($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAclForGuestSpace'][0])
    {
        list($response) = $this->getPreviewRecordAclForGuestSpaceWithHttpInfo($guest_space_id, $app, $lang, $contentType);
        return $response;
    }

    /**
     * Operation getPreviewRecordAclForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetPreviewRecordAclForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPreviewRecordAclForGuestSpaceWithHttpInfo($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAclForGuestSpace'][0])
    {
        $request = $this->getPreviewRecordAclForGuestSpaceRequest($guest_space_id, $app, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetPreviewRecordAclForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetPreviewRecordAclForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetPreviewRecordAclForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPreviewRecordAclForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreviewRecordAclForGuestSpaceAsync($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAclForGuestSpace'][0])
    {
        return $this->getPreviewRecordAclForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPreviewRecordAclForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreviewRecordAclForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAclForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetPreviewRecordAclForGuestSpaceResponse';
        $request = $this->getPreviewRecordAclForGuestSpaceRequest($guest_space_id, $app, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPreviewRecordAclForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPreviewRecordAclForGuestSpaceRequest($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getPreviewRecordAclForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getPreviewRecordAclForGuestSpace'
            );
        }

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getPreviewRecordAclForGuestSpace'
            );
        }



        $resourcePath = '/k/guest/{guestSpaceId}/v1/preview/record/acl.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecord
     *
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecord'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordResponse
     */
    public function getRecord($app, $id, string $contentType = self::contentTypes['getRecord'][0])
    {
        list($response) = $this->getRecordWithHttpInfo($app, $id, $contentType);
        return $response;
    }

    /**
     * Operation getRecordWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecord'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordWithHttpInfo($app, $id, string $contentType = self::contentTypes['getRecord'][0])
    {
        $request = $this->getRecordRequest($app, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordAsync
     *
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordAsync($app, $id, string $contentType = self::contentTypes['getRecord'][0])
    {
        return $this->getRecordAsyncWithHttpInfo($app, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordAsyncWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordAsyncWithHttpInfo($app, $id, string $contentType = self::contentTypes['getRecord'][0])
    {
        $returnType = '\Kintone\Model\GetRecordResponse';
        $request = $this->getRecordRequest($app, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecord'
     *
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordRequest($app, $id, string $contentType = self::contentTypes['getRecord'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecord'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecord'
            );
        }


        $resourcePath = '/k/v1/record.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordAcl
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAcl'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordAclResponse
     */
    public function getRecordAcl($app, $lang = null, string $contentType = self::contentTypes['getRecordAcl'][0])
    {
        list($response) = $this->getRecordAclWithHttpInfo($app, $lang, $contentType);
        return $response;
    }

    /**
     * Operation getRecordAclWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAcl'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordAclResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordAclWithHttpInfo($app, $lang = null, string $contentType = self::contentTypes['getRecordAcl'][0])
    {
        $request = $this->getRecordAclRequest($app, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordAclResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordAclResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordAclResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordAclAsync
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordAclAsync($app, $lang = null, string $contentType = self::contentTypes['getRecordAcl'][0])
    {
        return $this->getRecordAclAsyncWithHttpInfo($app, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordAclAsyncWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordAclAsyncWithHttpInfo($app, $lang = null, string $contentType = self::contentTypes['getRecordAcl'][0])
    {
        $returnType = '\Kintone\Model\GetRecordAclResponse';
        $request = $this->getRecordAclRequest($app, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordAcl'
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordAclRequest($app, $lang = null, string $contentType = self::contentTypes['getRecordAcl'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecordAcl'
            );
        }



        $resourcePath = '/k/v1/record/acl.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordAclForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordAclForGuestSpaceResponse
     */
    public function getRecordAclForGuestSpace($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getRecordAclForGuestSpace'][0])
    {
        list($response) = $this->getRecordAclForGuestSpaceWithHttpInfo($guest_space_id, $app, $lang, $contentType);
        return $response;
    }

    /**
     * Operation getRecordAclForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordAclForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordAclForGuestSpaceWithHttpInfo($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getRecordAclForGuestSpace'][0])
    {
        $request = $this->getRecordAclForGuestSpaceRequest($guest_space_id, $app, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordAclForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordAclForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordAclForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordAclForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordAclForGuestSpaceAsync($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getRecordAclForGuestSpace'][0])
    {
        return $this->getRecordAclForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordAclForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordAclForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getRecordAclForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetRecordAclForGuestSpaceResponse';
        $request = $this->getRecordAclForGuestSpaceRequest($guest_space_id, $app, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordAclForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $lang The localized language to retrieve the data in: - default: retrieves the default names - en: retrieves the localized English names - zh: retrieves the localized Chinese names - ja: retrieves the localized Japanese names - user: retrieves the localized names, in the same language as the language setting* set on the user used for the authentication.  If ignored, the default names will be retrieved. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordAclForGuestSpaceRequest($guest_space_id, $app, $lang = null, string $contentType = self::contentTypes['getRecordAclForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getRecordAclForGuestSpace'
            );
        }

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecordAclForGuestSpace'
            );
        }



        $resourcePath = '/k/guest/{guestSpaceId}/v1/record/acl.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordComments
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordComments'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordCommentsResponse
     */
    public function getRecordComments($app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordComments'][0])
    {
        list($response) = $this->getRecordCommentsWithHttpInfo($app, $record, $offset, $limit, $order, $contentType);
        return $response;
    }

    /**
     * Operation getRecordCommentsWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordComments'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordCommentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordCommentsWithHttpInfo($app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordComments'][0])
    {
        $request = $this->getRecordCommentsRequest($app, $record, $offset, $limit, $order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordCommentsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordCommentsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordCommentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordCommentsAsync
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordCommentsAsync($app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordComments'][0])
    {
        return $this->getRecordCommentsAsyncWithHttpInfo($app, $record, $offset, $limit, $order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordCommentsAsyncWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordCommentsAsyncWithHttpInfo($app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordComments'][0])
    {
        $returnType = '\Kintone\Model\GetRecordCommentsResponse';
        $request = $this->getRecordCommentsRequest($app, $record, $offset, $limit, $order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordComments'
     *
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordCommentsRequest($app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordComments'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecordComments'
            );
        }

        // verify the required parameter 'record' is set
        if ($record === null || (is_array($record) && count($record) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $record when calling getRecordComments'
            );
        }





        $resourcePath = '/k/v1/record/comments.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $record,
            'record', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordCommentsForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordCommentsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordCommentsForGuestSpaceResponse
     */
    public function getRecordCommentsForGuestSpace($guest_space_id, $app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordCommentsForGuestSpace'][0])
    {
        list($response) = $this->getRecordCommentsForGuestSpaceWithHttpInfo($guest_space_id, $app, $record, $offset, $limit, $order, $contentType);
        return $response;
    }

    /**
     * Operation getRecordCommentsForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordCommentsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordCommentsForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordCommentsForGuestSpaceWithHttpInfo($guest_space_id, $app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordCommentsForGuestSpace'][0])
    {
        $request = $this->getRecordCommentsForGuestSpaceRequest($guest_space_id, $app, $record, $offset, $limit, $order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordCommentsForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordCommentsForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordCommentsForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordCommentsForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordCommentsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordCommentsForGuestSpaceAsync($guest_space_id, $app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordCommentsForGuestSpace'][0])
    {
        return $this->getRecordCommentsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $record, $offset, $limit, $order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordCommentsForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordCommentsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordCommentsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordCommentsForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetRecordCommentsForGuestSpaceResponse';
        $request = $this->getRecordCommentsForGuestSpaceRequest($guest_space_id, $app, $record, $offset, $limit, $order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordCommentsForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $record The Record ID. (required)
     * @param  int|null $offset This skips the retrieval of the first number of comments. \&quot;offset\&quot;: 30 skips the first 30 comments, and retrieves from the 31st comment. There is no maximum for this value. (optional)
     * @param  int|null $limit The number of records to retrieve. \&quot;limit\&quot;: 5 will retrieve the first 5 comments. The default and maximum is 10 comments. (optional)
     * @param  string|null $order The sort order of the Comment ID. Specifying \&quot;asc\&quot; will sort the comments in ascending order, and \&quot;desc\&quot; will sort the comments in descending order. If ignored, \&quot;desc\&quot; will be set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordCommentsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordCommentsForGuestSpaceRequest($guest_space_id, $app, $record, $offset = null, $limit = null, $order = null, string $contentType = self::contentTypes['getRecordCommentsForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getRecordCommentsForGuestSpace'
            );
        }

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecordCommentsForGuestSpace'
            );
        }

        // verify the required parameter 'record' is set
        if ($record === null || (is_array($record) && count($record) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $record when calling getRecordCommentsForGuestSpace'
            );
        }





        $resourcePath = '/k/guest/{guestSpaceId}/v1/record/comments.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $record,
            'record', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordForGuestSpaceResponse
     */
    public function getRecordForGuestSpace($guest_space_id, $app, $id, string $contentType = self::contentTypes['getRecordForGuestSpace'][0])
    {
        list($response) = $this->getRecordForGuestSpaceWithHttpInfo($guest_space_id, $app, $id, $contentType);
        return $response;
    }

    /**
     * Operation getRecordForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordForGuestSpaceWithHttpInfo($guest_space_id, $app, $id, string $contentType = self::contentTypes['getRecordForGuestSpace'][0])
    {
        $request = $this->getRecordForGuestSpaceRequest($guest_space_id, $app, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordForGuestSpaceAsync($guest_space_id, $app, $id, string $contentType = self::contentTypes['getRecordForGuestSpace'][0])
    {
        return $this->getRecordForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $id, string $contentType = self::contentTypes['getRecordForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetRecordForGuestSpaceResponse';
        $request = $this->getRecordForGuestSpaceRequest($guest_space_id, $app, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int $id The Record ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordForGuestSpaceRequest($guest_space_id, $app, $id, string $contentType = self::contentTypes['getRecordForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getRecordForGuestSpace'
            );
        }

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecordForGuestSpace'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecordForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/record.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecords
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecords'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordsResponse
     */
    public function getRecords($app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecords'][0])
    {
        list($response) = $this->getRecordsWithHttpInfo($app, $query, $fields, $total_count, $contentType);
        return $response;
    }

    /**
     * Operation getRecordsWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecords'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordsWithHttpInfo($app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecords'][0])
    {
        $request = $this->getRecordsRequest($app, $query, $fields, $total_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordsAsync
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsAsync($app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecords'][0])
    {
        return $this->getRecordsAsyncWithHttpInfo($app, $query, $fields, $total_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordsAsyncWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsAsyncWithHttpInfo($app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecords'][0])
    {
        $returnType = '\Kintone\Model\GetRecordsResponse';
        $request = $this->getRecordsRequest($app, $query, $fields, $total_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecords'
     *
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordsRequest($app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecords'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecords'
            );
        }





        $resourcePath = '/k/v1/records.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $total_count,
            'totalCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordsAclEvaluate
     *
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluate'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordsAclEvaluateResponse
     */
    public function getRecordsAclEvaluate($app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluate'][0])
    {
        list($response) = $this->getRecordsAclEvaluateWithHttpInfo($app, $ids, $contentType);
        return $response;
    }

    /**
     * Operation getRecordsAclEvaluateWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluate'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordsAclEvaluateResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordsAclEvaluateWithHttpInfo($app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluate'][0])
    {
        $request = $this->getRecordsAclEvaluateRequest($app, $ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordsAclEvaluateResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordsAclEvaluateResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordsAclEvaluateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordsAclEvaluateAsync
     *
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsAclEvaluateAsync($app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluate'][0])
    {
        return $this->getRecordsAclEvaluateAsyncWithHttpInfo($app, $ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordsAclEvaluateAsyncWithHttpInfo
     *
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsAclEvaluateAsyncWithHttpInfo($app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluate'][0])
    {
        $returnType = '\Kintone\Model\GetRecordsAclEvaluateResponse';
        $request = $this->getRecordsAclEvaluateRequest($app, $ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordsAclEvaluate'
     *
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordsAclEvaluateRequest($app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluate'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecordsAclEvaluate'
            );
        }

        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getRecordsAclEvaluate'
            );
        }


        $resourcePath = '/k/v1/records/acl/evaluate.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordsAclEvaluateForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluateForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordsAclEvaluateForGuestSpaceResponse
     */
    public function getRecordsAclEvaluateForGuestSpace($guest_space_id, $app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluateForGuestSpace'][0])
    {
        list($response) = $this->getRecordsAclEvaluateForGuestSpaceWithHttpInfo($guest_space_id, $app, $ids, $contentType);
        return $response;
    }

    /**
     * Operation getRecordsAclEvaluateForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluateForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordsAclEvaluateForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordsAclEvaluateForGuestSpaceWithHttpInfo($guest_space_id, $app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluateForGuestSpace'][0])
    {
        $request = $this->getRecordsAclEvaluateForGuestSpaceRequest($guest_space_id, $app, $ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordsAclEvaluateForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordsAclEvaluateForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordsAclEvaluateForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordsAclEvaluateForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluateForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsAclEvaluateForGuestSpaceAsync($guest_space_id, $app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluateForGuestSpace'][0])
    {
        return $this->getRecordsAclEvaluateForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordsAclEvaluateForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluateForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsAclEvaluateForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluateForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetRecordsAclEvaluateForGuestSpaceResponse';
        $request = $this->getRecordsAclEvaluateForGuestSpaceRequest($guest_space_id, $app, $ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordsAclEvaluateForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  int[] $ids An array of record IDs that will be evaluated. The maximum limit is 100 IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsAclEvaluateForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordsAclEvaluateForGuestSpaceRequest($guest_space_id, $app, $ids, string $contentType = self::contentTypes['getRecordsAclEvaluateForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getRecordsAclEvaluateForGuestSpace'
            );
        }

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecordsAclEvaluateForGuestSpace'
            );
        }

        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getRecordsAclEvaluateForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/records/acl/evaluate.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordsCursor
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursor'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordsCursorResponse
     */
    public function getRecordsCursor($id, string $contentType = self::contentTypes['getRecordsCursor'][0])
    {
        list($response) = $this->getRecordsCursorWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getRecordsCursorWithHttpInfo
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursor'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordsCursorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordsCursorWithHttpInfo($id, string $contentType = self::contentTypes['getRecordsCursor'][0])
    {
        $request = $this->getRecordsCursorRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordsCursorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordsCursorResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordsCursorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordsCursorAsync
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsCursorAsync($id, string $contentType = self::contentTypes['getRecordsCursor'][0])
    {
        return $this->getRecordsCursorAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordsCursorAsyncWithHttpInfo
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsCursorAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getRecordsCursor'][0])
    {
        $returnType = '\Kintone\Model\GetRecordsCursorResponse';
        $request = $this->getRecordsCursorRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordsCursor'
     *
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordsCursorRequest($id, string $contentType = self::contentTypes['getRecordsCursor'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecordsCursor'
            );
        }


        $resourcePath = '/k/v1/records/cursor.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordsCursorForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordsCursorForGuestSpaceResponse
     */
    public function getRecordsCursorForGuestSpace($guest_space_id, $id, string $contentType = self::contentTypes['getRecordsCursorForGuestSpace'][0])
    {
        list($response) = $this->getRecordsCursorForGuestSpaceWithHttpInfo($guest_space_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation getRecordsCursorForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordsCursorForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordsCursorForGuestSpaceWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['getRecordsCursorForGuestSpace'][0])
    {
        $request = $this->getRecordsCursorForGuestSpaceRequest($guest_space_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordsCursorForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordsCursorForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordsCursorForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordsCursorForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsCursorForGuestSpaceAsync($guest_space_id, $id, string $contentType = self::contentTypes['getRecordsCursorForGuestSpace'][0])
    {
        return $this->getRecordsCursorForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordsCursorForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsCursorForGuestSpaceAsyncWithHttpInfo($guest_space_id, $id, string $contentType = self::contentTypes['getRecordsCursorForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetRecordsCursorForGuestSpaceResponse';
        $request = $this->getRecordsCursorForGuestSpaceRequest($guest_space_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordsCursorForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  string $id The cursor ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordsCursorForGuestSpaceRequest($guest_space_id, $id, string $contentType = self::contentTypes['getRecordsCursorForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getRecordsCursorForGuestSpace'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecordsCursorForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/records/cursor.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordsForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\GetRecordsForGuestSpaceResponse
     */
    public function getRecordsForGuestSpace($guest_space_id, $app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecordsForGuestSpace'][0])
    {
        list($response) = $this->getRecordsForGuestSpaceWithHttpInfo($guest_space_id, $app, $query, $fields, $total_count, $contentType);
        return $response;
    }

    /**
     * Operation getRecordsForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\GetRecordsForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordsForGuestSpaceWithHttpInfo($guest_space_id, $app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecordsForGuestSpace'][0])
    {
        $request = $this->getRecordsForGuestSpaceRequest($guest_space_id, $app, $query, $fields, $total_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\GetRecordsForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\GetRecordsForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\GetRecordsForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecordsForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsForGuestSpaceAsync($guest_space_id, $app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecordsForGuestSpace'][0])
    {
        return $this->getRecordsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $query, $fields, $total_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordsForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsForGuestSpaceAsyncWithHttpInfo($guest_space_id, $app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecordsForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\GetRecordsForGuestSpaceResponse';
        $request = $this->getRecordsForGuestSpaceRequest($guest_space_id, $app, $query, $fields, $total_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordsForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  int $app The App ID. (required)
     * @param  string|null $query The query string that specifies what records to include in the response. Ignoring this parameter will return all accessible records from the App. (optional)
     * @param  string[]|null $fields The field codes to be included in the response. Ignoring this parameter will return all accessible fields that exist in the App. (optional)
     * @param  bool|null $total_count If set to true, the total count of records that match the query conditions will be included in the response. If ignored, null is returned for the totalCount value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordsForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordsForGuestSpaceRequest($guest_space_id, $app, $query = null, $fields = null, $total_count = null, string $contentType = self::contentTypes['getRecordsForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling getRecordsForGuestSpace'
            );
        }

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling getRecordsForGuestSpace'
            );
        }





        $resourcePath = '/k/guest/{guestSpaceId}/v1/records.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app,
            'app', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $total_count,
            'totalCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postBulkRequest
     *
     * @param  \Kintone\Model\PostBulkRequestRequest $post_bulk_request_request post_bulk_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequest'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostBulkRequestResponse
     */
    public function postBulkRequest($post_bulk_request_request, string $contentType = self::contentTypes['postBulkRequest'][0])
    {
        list($response) = $this->postBulkRequestWithHttpInfo($post_bulk_request_request, $contentType);
        return $response;
    }

    /**
     * Operation postBulkRequestWithHttpInfo
     *
     * @param  \Kintone\Model\PostBulkRequestRequest $post_bulk_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequest'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostBulkRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postBulkRequestWithHttpInfo($post_bulk_request_request, string $contentType = self::contentTypes['postBulkRequest'][0])
    {
        $request = $this->postBulkRequestRequest($post_bulk_request_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostBulkRequestResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostBulkRequestResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostBulkRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postBulkRequestAsync
     *
     * @param  \Kintone\Model\PostBulkRequestRequest $post_bulk_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBulkRequestAsync($post_bulk_request_request, string $contentType = self::contentTypes['postBulkRequest'][0])
    {
        return $this->postBulkRequestAsyncWithHttpInfo($post_bulk_request_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postBulkRequestAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PostBulkRequestRequest $post_bulk_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBulkRequestAsyncWithHttpInfo($post_bulk_request_request, string $contentType = self::contentTypes['postBulkRequest'][0])
    {
        $returnType = '\Kintone\Model\PostBulkRequestResponse';
        $request = $this->postBulkRequestRequest($post_bulk_request_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postBulkRequest'
     *
     * @param  \Kintone\Model\PostBulkRequestRequest $post_bulk_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postBulkRequestRequest($post_bulk_request_request, string $contentType = self::contentTypes['postBulkRequest'][0])
    {

        // verify the required parameter 'post_bulk_request_request' is set
        if ($post_bulk_request_request === null || (is_array($post_bulk_request_request) && count($post_bulk_request_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_bulk_request_request when calling postBulkRequest'
            );
        }


        $resourcePath = '/k/v1/bulkRequest.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_bulk_request_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_bulk_request_request));
            } else {
                $httpBody = $post_bulk_request_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postBulkRequestForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostBulkRequestForGuestSpaceRequest $post_bulk_request_for_guest_space_request post_bulk_request_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequestForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostBulkRequestForGuestSpaceResponse
     */
    public function postBulkRequestForGuestSpace($guest_space_id, $post_bulk_request_for_guest_space_request, string $contentType = self::contentTypes['postBulkRequestForGuestSpace'][0])
    {
        list($response) = $this->postBulkRequestForGuestSpaceWithHttpInfo($guest_space_id, $post_bulk_request_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postBulkRequestForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostBulkRequestForGuestSpaceRequest $post_bulk_request_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequestForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostBulkRequestForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postBulkRequestForGuestSpaceWithHttpInfo($guest_space_id, $post_bulk_request_for_guest_space_request, string $contentType = self::contentTypes['postBulkRequestForGuestSpace'][0])
    {
        $request = $this->postBulkRequestForGuestSpaceRequest($guest_space_id, $post_bulk_request_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostBulkRequestForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostBulkRequestForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostBulkRequestForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postBulkRequestForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostBulkRequestForGuestSpaceRequest $post_bulk_request_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequestForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBulkRequestForGuestSpaceAsync($guest_space_id, $post_bulk_request_for_guest_space_request, string $contentType = self::contentTypes['postBulkRequestForGuestSpace'][0])
    {
        return $this->postBulkRequestForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_bulk_request_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postBulkRequestForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostBulkRequestForGuestSpaceRequest $post_bulk_request_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequestForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBulkRequestForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_bulk_request_for_guest_space_request, string $contentType = self::contentTypes['postBulkRequestForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PostBulkRequestForGuestSpaceResponse';
        $request = $this->postBulkRequestForGuestSpaceRequest($guest_space_id, $post_bulk_request_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postBulkRequestForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostBulkRequestForGuestSpaceRequest $post_bulk_request_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBulkRequestForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postBulkRequestForGuestSpaceRequest($guest_space_id, $post_bulk_request_for_guest_space_request, string $contentType = self::contentTypes['postBulkRequestForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling postBulkRequestForGuestSpace'
            );
        }

        // verify the required parameter 'post_bulk_request_for_guest_space_request' is set
        if ($post_bulk_request_for_guest_space_request === null || (is_array($post_bulk_request_for_guest_space_request) && count($post_bulk_request_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_bulk_request_for_guest_space_request when calling postBulkRequestForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/bulkRequest.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_bulk_request_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_bulk_request_for_guest_space_request));
            } else {
                $httpBody = $post_bulk_request_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRecord
     *
     * @param  \Kintone\Model\PostRecordRequest $post_record_request post_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecord'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostRecordResponse
     */
    public function postRecord($post_record_request, string $contentType = self::contentTypes['postRecord'][0])
    {
        list($response) = $this->postRecordWithHttpInfo($post_record_request, $contentType);
        return $response;
    }

    /**
     * Operation postRecordWithHttpInfo
     *
     * @param  \Kintone\Model\PostRecordRequest $post_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecord'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostRecordResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRecordWithHttpInfo($post_record_request, string $contentType = self::contentTypes['postRecord'][0])
    {
        $request = $this->postRecordRequest($post_record_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostRecordResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostRecordResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostRecordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postRecordAsync
     *
     * @param  \Kintone\Model\PostRecordRequest $post_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordAsync($post_record_request, string $contentType = self::contentTypes['postRecord'][0])
    {
        return $this->postRecordAsyncWithHttpInfo($post_record_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRecordAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PostRecordRequest $post_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordAsyncWithHttpInfo($post_record_request, string $contentType = self::contentTypes['postRecord'][0])
    {
        $returnType = '\Kintone\Model\PostRecordResponse';
        $request = $this->postRecordRequest($post_record_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRecord'
     *
     * @param  \Kintone\Model\PostRecordRequest $post_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postRecordRequest($post_record_request, string $contentType = self::contentTypes['postRecord'][0])
    {

        // verify the required parameter 'post_record_request' is set
        if ($post_record_request === null || (is_array($post_record_request) && count($post_record_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_record_request when calling postRecord'
            );
        }


        $resourcePath = '/k/v1/record.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_record_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_record_request));
            } else {
                $httpBody = $post_record_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRecordComment
     *
     * @param  \Kintone\Model\PostRecordCommentRequest $post_record_comment_request post_record_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordComment'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostRecordCommentResponse
     */
    public function postRecordComment($post_record_comment_request, string $contentType = self::contentTypes['postRecordComment'][0])
    {
        list($response) = $this->postRecordCommentWithHttpInfo($post_record_comment_request, $contentType);
        return $response;
    }

    /**
     * Operation postRecordCommentWithHttpInfo
     *
     * @param  \Kintone\Model\PostRecordCommentRequest $post_record_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordComment'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostRecordCommentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRecordCommentWithHttpInfo($post_record_comment_request, string $contentType = self::contentTypes['postRecordComment'][0])
    {
        $request = $this->postRecordCommentRequest($post_record_comment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostRecordCommentResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostRecordCommentResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostRecordCommentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postRecordCommentAsync
     *
     * @param  \Kintone\Model\PostRecordCommentRequest $post_record_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordCommentAsync($post_record_comment_request, string $contentType = self::contentTypes['postRecordComment'][0])
    {
        return $this->postRecordCommentAsyncWithHttpInfo($post_record_comment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRecordCommentAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PostRecordCommentRequest $post_record_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordCommentAsyncWithHttpInfo($post_record_comment_request, string $contentType = self::contentTypes['postRecordComment'][0])
    {
        $returnType = '\Kintone\Model\PostRecordCommentResponse';
        $request = $this->postRecordCommentRequest($post_record_comment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRecordComment'
     *
     * @param  \Kintone\Model\PostRecordCommentRequest $post_record_comment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postRecordCommentRequest($post_record_comment_request, string $contentType = self::contentTypes['postRecordComment'][0])
    {

        // verify the required parameter 'post_record_comment_request' is set
        if ($post_record_comment_request === null || (is_array($post_record_comment_request) && count($post_record_comment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_record_comment_request when calling postRecordComment'
            );
        }


        $resourcePath = '/k/v1/record/comment.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_record_comment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_record_comment_request));
            } else {
                $httpBody = $post_record_comment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRecordCommentForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordCommentForGuestSpaceRequest $post_record_comment_for_guest_space_request post_record_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostRecordCommentForGuestSpaceResponse
     */
    public function postRecordCommentForGuestSpace($guest_space_id, $post_record_comment_for_guest_space_request, string $contentType = self::contentTypes['postRecordCommentForGuestSpace'][0])
    {
        list($response) = $this->postRecordCommentForGuestSpaceWithHttpInfo($guest_space_id, $post_record_comment_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postRecordCommentForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordCommentForGuestSpaceRequest $post_record_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostRecordCommentForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRecordCommentForGuestSpaceWithHttpInfo($guest_space_id, $post_record_comment_for_guest_space_request, string $contentType = self::contentTypes['postRecordCommentForGuestSpace'][0])
    {
        $request = $this->postRecordCommentForGuestSpaceRequest($guest_space_id, $post_record_comment_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostRecordCommentForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostRecordCommentForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostRecordCommentForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postRecordCommentForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordCommentForGuestSpaceRequest $post_record_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordCommentForGuestSpaceAsync($guest_space_id, $post_record_comment_for_guest_space_request, string $contentType = self::contentTypes['postRecordCommentForGuestSpace'][0])
    {
        return $this->postRecordCommentForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_record_comment_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRecordCommentForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordCommentForGuestSpaceRequest $post_record_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordCommentForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_record_comment_for_guest_space_request, string $contentType = self::contentTypes['postRecordCommentForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PostRecordCommentForGuestSpaceResponse';
        $request = $this->postRecordCommentForGuestSpaceRequest($guest_space_id, $post_record_comment_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRecordCommentForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordCommentForGuestSpaceRequest $post_record_comment_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordCommentForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postRecordCommentForGuestSpaceRequest($guest_space_id, $post_record_comment_for_guest_space_request, string $contentType = self::contentTypes['postRecordCommentForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling postRecordCommentForGuestSpace'
            );
        }

        // verify the required parameter 'post_record_comment_for_guest_space_request' is set
        if ($post_record_comment_for_guest_space_request === null || (is_array($post_record_comment_for_guest_space_request) && count($post_record_comment_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_record_comment_for_guest_space_request when calling postRecordCommentForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/record/comment.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_record_comment_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_record_comment_for_guest_space_request));
            } else {
                $httpBody = $post_record_comment_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRecordForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordForGuestSpaceRequest $post_record_for_guest_space_request post_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostRecordForGuestSpaceResponse
     */
    public function postRecordForGuestSpace($guest_space_id, $post_record_for_guest_space_request, string $contentType = self::contentTypes['postRecordForGuestSpace'][0])
    {
        list($response) = $this->postRecordForGuestSpaceWithHttpInfo($guest_space_id, $post_record_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postRecordForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordForGuestSpaceRequest $post_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostRecordForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRecordForGuestSpaceWithHttpInfo($guest_space_id, $post_record_for_guest_space_request, string $contentType = self::contentTypes['postRecordForGuestSpace'][0])
    {
        $request = $this->postRecordForGuestSpaceRequest($guest_space_id, $post_record_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostRecordForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostRecordForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostRecordForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postRecordForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordForGuestSpaceRequest $post_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordForGuestSpaceAsync($guest_space_id, $post_record_for_guest_space_request, string $contentType = self::contentTypes['postRecordForGuestSpace'][0])
    {
        return $this->postRecordForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_record_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRecordForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordForGuestSpaceRequest $post_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_record_for_guest_space_request, string $contentType = self::contentTypes['postRecordForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PostRecordForGuestSpaceResponse';
        $request = $this->postRecordForGuestSpaceRequest($guest_space_id, $post_record_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRecordForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordForGuestSpaceRequest $post_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postRecordForGuestSpaceRequest($guest_space_id, $post_record_for_guest_space_request, string $contentType = self::contentTypes['postRecordForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling postRecordForGuestSpace'
            );
        }

        // verify the required parameter 'post_record_for_guest_space_request' is set
        if ($post_record_for_guest_space_request === null || (is_array($post_record_for_guest_space_request) && count($post_record_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_record_for_guest_space_request when calling postRecordForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/record.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_record_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_record_for_guest_space_request));
            } else {
                $httpBody = $post_record_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRecordsCursor
     *
     * @param  \Kintone\Model\PostRecordsCursorRequest $post_records_cursor_request post_records_cursor_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursor'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostRecordsCursorResponse
     */
    public function postRecordsCursor($post_records_cursor_request, string $contentType = self::contentTypes['postRecordsCursor'][0])
    {
        list($response) = $this->postRecordsCursorWithHttpInfo($post_records_cursor_request, $contentType);
        return $response;
    }

    /**
     * Operation postRecordsCursorWithHttpInfo
     *
     * @param  \Kintone\Model\PostRecordsCursorRequest $post_records_cursor_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursor'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostRecordsCursorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRecordsCursorWithHttpInfo($post_records_cursor_request, string $contentType = self::contentTypes['postRecordsCursor'][0])
    {
        $request = $this->postRecordsCursorRequest($post_records_cursor_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostRecordsCursorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostRecordsCursorResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostRecordsCursorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postRecordsCursorAsync
     *
     * @param  \Kintone\Model\PostRecordsCursorRequest $post_records_cursor_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordsCursorAsync($post_records_cursor_request, string $contentType = self::contentTypes['postRecordsCursor'][0])
    {
        return $this->postRecordsCursorAsyncWithHttpInfo($post_records_cursor_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRecordsCursorAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PostRecordsCursorRequest $post_records_cursor_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordsCursorAsyncWithHttpInfo($post_records_cursor_request, string $contentType = self::contentTypes['postRecordsCursor'][0])
    {
        $returnType = '\Kintone\Model\PostRecordsCursorResponse';
        $request = $this->postRecordsCursorRequest($post_records_cursor_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRecordsCursor'
     *
     * @param  \Kintone\Model\PostRecordsCursorRequest $post_records_cursor_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postRecordsCursorRequest($post_records_cursor_request, string $contentType = self::contentTypes['postRecordsCursor'][0])
    {

        // verify the required parameter 'post_records_cursor_request' is set
        if ($post_records_cursor_request === null || (is_array($post_records_cursor_request) && count($post_records_cursor_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_records_cursor_request when calling postRecordsCursor'
            );
        }


        $resourcePath = '/k/v1/records/cursor.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_records_cursor_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_records_cursor_request));
            } else {
                $httpBody = $post_records_cursor_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postRecordsCursorForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsCursorForGuestSpaceRequest $post_records_cursor_for_guest_space_request post_records_cursor_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PostRecordsCursorForGuestSpaceResponse
     */
    public function postRecordsCursorForGuestSpace($guest_space_id, $post_records_cursor_for_guest_space_request, string $contentType = self::contentTypes['postRecordsCursorForGuestSpace'][0])
    {
        list($response) = $this->postRecordsCursorForGuestSpaceWithHttpInfo($guest_space_id, $post_records_cursor_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation postRecordsCursorForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsCursorForGuestSpaceRequest $post_records_cursor_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PostRecordsCursorForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postRecordsCursorForGuestSpaceWithHttpInfo($guest_space_id, $post_records_cursor_for_guest_space_request, string $contentType = self::contentTypes['postRecordsCursorForGuestSpace'][0])
    {
        $request = $this->postRecordsCursorForGuestSpaceRequest($guest_space_id, $post_records_cursor_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PostRecordsCursorForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PostRecordsCursorForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PostRecordsCursorForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation postRecordsCursorForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsCursorForGuestSpaceRequest $post_records_cursor_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordsCursorForGuestSpaceAsync($guest_space_id, $post_records_cursor_for_guest_space_request, string $contentType = self::contentTypes['postRecordsCursorForGuestSpace'][0])
    {
        return $this->postRecordsCursorForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_records_cursor_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postRecordsCursorForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsCursorForGuestSpaceRequest $post_records_cursor_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postRecordsCursorForGuestSpaceAsyncWithHttpInfo($guest_space_id, $post_records_cursor_for_guest_space_request, string $contentType = self::contentTypes['postRecordsCursorForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PostRecordsCursorForGuestSpaceResponse';
        $request = $this->postRecordsCursorForGuestSpaceRequest($guest_space_id, $post_records_cursor_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postRecordsCursorForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PostRecordsCursorForGuestSpaceRequest $post_records_cursor_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postRecordsCursorForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postRecordsCursorForGuestSpaceRequest($guest_space_id, $post_records_cursor_for_guest_space_request, string $contentType = self::contentTypes['postRecordsCursorForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling postRecordsCursorForGuestSpace'
            );
        }

        // verify the required parameter 'post_records_cursor_for_guest_space_request' is set
        if ($post_records_cursor_for_guest_space_request === null || (is_array($post_records_cursor_for_guest_space_request) && count($post_records_cursor_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_records_cursor_for_guest_space_request when calling postRecordsCursorForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/records/cursor.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_records_cursor_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_records_cursor_for_guest_space_request));
            } else {
                $httpBody = $post_records_cursor_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPreviewRecordAcl
     *
     * @param  \Kintone\Model\PutPreviewRecordAclRequest $put_preview_record_acl_request put_preview_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutPreviewRecordAclResponse
     */
    public function putPreviewRecordAcl($put_preview_record_acl_request, string $contentType = self::contentTypes['putPreviewRecordAcl'][0])
    {
        list($response) = $this->putPreviewRecordAclWithHttpInfo($put_preview_record_acl_request, $contentType);
        return $response;
    }

    /**
     * Operation putPreviewRecordAclWithHttpInfo
     *
     * @param  \Kintone\Model\PutPreviewRecordAclRequest $put_preview_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutPreviewRecordAclResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPreviewRecordAclWithHttpInfo($put_preview_record_acl_request, string $contentType = self::contentTypes['putPreviewRecordAcl'][0])
    {
        $request = $this->putPreviewRecordAclRequest($put_preview_record_acl_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutPreviewRecordAclResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutPreviewRecordAclResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutPreviewRecordAclResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putPreviewRecordAclAsync
     *
     * @param  \Kintone\Model\PutPreviewRecordAclRequest $put_preview_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPreviewRecordAclAsync($put_preview_record_acl_request, string $contentType = self::contentTypes['putPreviewRecordAcl'][0])
    {
        return $this->putPreviewRecordAclAsyncWithHttpInfo($put_preview_record_acl_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPreviewRecordAclAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutPreviewRecordAclRequest $put_preview_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPreviewRecordAclAsyncWithHttpInfo($put_preview_record_acl_request, string $contentType = self::contentTypes['putPreviewRecordAcl'][0])
    {
        $returnType = '\Kintone\Model\PutPreviewRecordAclResponse';
        $request = $this->putPreviewRecordAclRequest($put_preview_record_acl_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPreviewRecordAcl'
     *
     * @param  \Kintone\Model\PutPreviewRecordAclRequest $put_preview_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putPreviewRecordAclRequest($put_preview_record_acl_request, string $contentType = self::contentTypes['putPreviewRecordAcl'][0])
    {

        // verify the required parameter 'put_preview_record_acl_request' is set
        if ($put_preview_record_acl_request === null || (is_array($put_preview_record_acl_request) && count($put_preview_record_acl_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_preview_record_acl_request when calling putPreviewRecordAcl'
            );
        }


        $resourcePath = '/k/v1/preview/record/acl.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_preview_record_acl_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_preview_record_acl_request));
            } else {
                $httpBody = $put_preview_record_acl_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPreviewRecordAclForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutPreviewRecordAclForGuestSpaceRequest $put_preview_record_acl_for_guest_space_request put_preview_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutPreviewRecordAclForGuestSpaceResponse
     */
    public function putPreviewRecordAclForGuestSpace($guest_space_id, $put_preview_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putPreviewRecordAclForGuestSpace'][0])
    {
        list($response) = $this->putPreviewRecordAclForGuestSpaceWithHttpInfo($guest_space_id, $put_preview_record_acl_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putPreviewRecordAclForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutPreviewRecordAclForGuestSpaceRequest $put_preview_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutPreviewRecordAclForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPreviewRecordAclForGuestSpaceWithHttpInfo($guest_space_id, $put_preview_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putPreviewRecordAclForGuestSpace'][0])
    {
        $request = $this->putPreviewRecordAclForGuestSpaceRequest($guest_space_id, $put_preview_record_acl_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutPreviewRecordAclForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutPreviewRecordAclForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutPreviewRecordAclForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putPreviewRecordAclForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutPreviewRecordAclForGuestSpaceRequest $put_preview_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPreviewRecordAclForGuestSpaceAsync($guest_space_id, $put_preview_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putPreviewRecordAclForGuestSpace'][0])
    {
        return $this->putPreviewRecordAclForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_preview_record_acl_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPreviewRecordAclForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutPreviewRecordAclForGuestSpaceRequest $put_preview_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPreviewRecordAclForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_preview_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putPreviewRecordAclForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PutPreviewRecordAclForGuestSpaceResponse';
        $request = $this->putPreviewRecordAclForGuestSpaceRequest($guest_space_id, $put_preview_record_acl_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPreviewRecordAclForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutPreviewRecordAclForGuestSpaceRequest $put_preview_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putPreviewRecordAclForGuestSpaceRequest($guest_space_id, $put_preview_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putPreviewRecordAclForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putPreviewRecordAclForGuestSpace'
            );
        }

        // verify the required parameter 'put_preview_record_acl_for_guest_space_request' is set
        if ($put_preview_record_acl_for_guest_space_request === null || (is_array($put_preview_record_acl_for_guest_space_request) && count($put_preview_record_acl_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_preview_record_acl_for_guest_space_request when calling putPreviewRecordAclForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/preview/record/acl.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_preview_record_acl_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_preview_record_acl_for_guest_space_request));
            } else {
                $httpBody = $put_preview_record_acl_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecord
     *
     * @param  \Kintone\Model\PutRecordRequest $put_record_request put_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecord'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordResponse
     */
    public function putRecord($put_record_request, string $contentType = self::contentTypes['putRecord'][0])
    {
        list($response) = $this->putRecordWithHttpInfo($put_record_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordRequest $put_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecord'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordWithHttpInfo($put_record_request, string $contentType = self::contentTypes['putRecord'][0])
    {
        $request = $this->putRecordRequest($put_record_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordAsync
     *
     * @param  \Kintone\Model\PutRecordRequest $put_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAsync($put_record_request, string $contentType = self::contentTypes['putRecord'][0])
    {
        return $this->putRecordAsyncWithHttpInfo($put_record_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordRequest $put_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAsyncWithHttpInfo($put_record_request, string $contentType = self::contentTypes['putRecord'][0])
    {
        $returnType = '\Kintone\Model\PutRecordResponse';
        $request = $this->putRecordRequest($put_record_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecord'
     *
     * @param  \Kintone\Model\PutRecordRequest $put_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordRequest($put_record_request, string $contentType = self::contentTypes['putRecord'][0])
    {

        // verify the required parameter 'put_record_request' is set
        if ($put_record_request === null || (is_array($put_record_request) && count($put_record_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_record_request when calling putRecord'
            );
        }


        $resourcePath = '/k/v1/record.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_record_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_record_request));
            } else {
                $httpBody = $put_record_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordAcl
     *
     * @param  \Kintone\Model\PutRecordAclRequest $put_record_acl_request put_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAcl'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordAclResponse
     */
    public function putRecordAcl($put_record_acl_request, string $contentType = self::contentTypes['putRecordAcl'][0])
    {
        list($response) = $this->putRecordAclWithHttpInfo($put_record_acl_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordAclWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordAclRequest $put_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAcl'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordAclResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordAclWithHttpInfo($put_record_acl_request, string $contentType = self::contentTypes['putRecordAcl'][0])
    {
        $request = $this->putRecordAclRequest($put_record_acl_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordAclResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordAclResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordAclResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordAclAsync
     *
     * @param  \Kintone\Model\PutRecordAclRequest $put_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAclAsync($put_record_acl_request, string $contentType = self::contentTypes['putRecordAcl'][0])
    {
        return $this->putRecordAclAsyncWithHttpInfo($put_record_acl_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordAclAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordAclRequest $put_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAclAsyncWithHttpInfo($put_record_acl_request, string $contentType = self::contentTypes['putRecordAcl'][0])
    {
        $returnType = '\Kintone\Model\PutRecordAclResponse';
        $request = $this->putRecordAclRequest($put_record_acl_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordAcl'
     *
     * @param  \Kintone\Model\PutRecordAclRequest $put_record_acl_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAcl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordAclRequest($put_record_acl_request, string $contentType = self::contentTypes['putRecordAcl'][0])
    {

        // verify the required parameter 'put_record_acl_request' is set
        if ($put_record_acl_request === null || (is_array($put_record_acl_request) && count($put_record_acl_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_record_acl_request when calling putRecordAcl'
            );
        }


        $resourcePath = '/k/v1/record/acl.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_record_acl_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_record_acl_request));
            } else {
                $httpBody = $put_record_acl_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordAclForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAclForGuestSpaceRequest $put_record_acl_for_guest_space_request put_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordAclForGuestSpaceResponse
     */
    public function putRecordAclForGuestSpace($guest_space_id, $put_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putRecordAclForGuestSpace'][0])
    {
        list($response) = $this->putRecordAclForGuestSpaceWithHttpInfo($guest_space_id, $put_record_acl_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordAclForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAclForGuestSpaceRequest $put_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordAclForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordAclForGuestSpaceWithHttpInfo($guest_space_id, $put_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putRecordAclForGuestSpace'][0])
    {
        $request = $this->putRecordAclForGuestSpaceRequest($guest_space_id, $put_record_acl_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordAclForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordAclForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordAclForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordAclForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAclForGuestSpaceRequest $put_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAclForGuestSpaceAsync($guest_space_id, $put_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putRecordAclForGuestSpace'][0])
    {
        return $this->putRecordAclForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_record_acl_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordAclForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAclForGuestSpaceRequest $put_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAclForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putRecordAclForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PutRecordAclForGuestSpaceResponse';
        $request = $this->putRecordAclForGuestSpaceRequest($guest_space_id, $put_record_acl_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordAclForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAclForGuestSpaceRequest $put_record_acl_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAclForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordAclForGuestSpaceRequest($guest_space_id, $put_record_acl_for_guest_space_request, string $contentType = self::contentTypes['putRecordAclForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putRecordAclForGuestSpace'
            );
        }

        // verify the required parameter 'put_record_acl_for_guest_space_request' is set
        if ($put_record_acl_for_guest_space_request === null || (is_array($put_record_acl_for_guest_space_request) && count($put_record_acl_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_record_acl_for_guest_space_request when calling putRecordAclForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/record/acl.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_record_acl_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_record_acl_for_guest_space_request));
            } else {
                $httpBody = $put_record_acl_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordAssignees
     *
     * @param  \Kintone\Model\PutRecordAssigneesRequest $put_record_assignees_request put_record_assignees_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssignees'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordAssigneesResponse
     */
    public function putRecordAssignees($put_record_assignees_request, string $contentType = self::contentTypes['putRecordAssignees'][0])
    {
        list($response) = $this->putRecordAssigneesWithHttpInfo($put_record_assignees_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordAssigneesWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordAssigneesRequest $put_record_assignees_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssignees'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordAssigneesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordAssigneesWithHttpInfo($put_record_assignees_request, string $contentType = self::contentTypes['putRecordAssignees'][0])
    {
        $request = $this->putRecordAssigneesRequest($put_record_assignees_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordAssigneesResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordAssigneesResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordAssigneesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordAssigneesAsync
     *
     * @param  \Kintone\Model\PutRecordAssigneesRequest $put_record_assignees_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssignees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAssigneesAsync($put_record_assignees_request, string $contentType = self::contentTypes['putRecordAssignees'][0])
    {
        return $this->putRecordAssigneesAsyncWithHttpInfo($put_record_assignees_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordAssigneesAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordAssigneesRequest $put_record_assignees_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssignees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAssigneesAsyncWithHttpInfo($put_record_assignees_request, string $contentType = self::contentTypes['putRecordAssignees'][0])
    {
        $returnType = '\Kintone\Model\PutRecordAssigneesResponse';
        $request = $this->putRecordAssigneesRequest($put_record_assignees_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordAssignees'
     *
     * @param  \Kintone\Model\PutRecordAssigneesRequest $put_record_assignees_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssignees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordAssigneesRequest($put_record_assignees_request, string $contentType = self::contentTypes['putRecordAssignees'][0])
    {

        // verify the required parameter 'put_record_assignees_request' is set
        if ($put_record_assignees_request === null || (is_array($put_record_assignees_request) && count($put_record_assignees_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_record_assignees_request when calling putRecordAssignees'
            );
        }


        $resourcePath = '/k/v1/record/assignees.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_record_assignees_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_record_assignees_request));
            } else {
                $httpBody = $put_record_assignees_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordAssigneesForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAssigneesForGuestSpaceRequest $put_record_assignees_for_guest_space_request put_record_assignees_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssigneesForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordAssigneesForGuestSpaceResponse
     */
    public function putRecordAssigneesForGuestSpace($guest_space_id, $put_record_assignees_for_guest_space_request, string $contentType = self::contentTypes['putRecordAssigneesForGuestSpace'][0])
    {
        list($response) = $this->putRecordAssigneesForGuestSpaceWithHttpInfo($guest_space_id, $put_record_assignees_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordAssigneesForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAssigneesForGuestSpaceRequest $put_record_assignees_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssigneesForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordAssigneesForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordAssigneesForGuestSpaceWithHttpInfo($guest_space_id, $put_record_assignees_for_guest_space_request, string $contentType = self::contentTypes['putRecordAssigneesForGuestSpace'][0])
    {
        $request = $this->putRecordAssigneesForGuestSpaceRequest($guest_space_id, $put_record_assignees_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordAssigneesForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordAssigneesForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordAssigneesForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordAssigneesForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAssigneesForGuestSpaceRequest $put_record_assignees_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssigneesForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAssigneesForGuestSpaceAsync($guest_space_id, $put_record_assignees_for_guest_space_request, string $contentType = self::contentTypes['putRecordAssigneesForGuestSpace'][0])
    {
        return $this->putRecordAssigneesForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_record_assignees_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordAssigneesForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAssigneesForGuestSpaceRequest $put_record_assignees_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssigneesForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordAssigneesForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_record_assignees_for_guest_space_request, string $contentType = self::contentTypes['putRecordAssigneesForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PutRecordAssigneesForGuestSpaceResponse';
        $request = $this->putRecordAssigneesForGuestSpaceRequest($guest_space_id, $put_record_assignees_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordAssigneesForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordAssigneesForGuestSpaceRequest $put_record_assignees_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordAssigneesForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordAssigneesForGuestSpaceRequest($guest_space_id, $put_record_assignees_for_guest_space_request, string $contentType = self::contentTypes['putRecordAssigneesForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putRecordAssigneesForGuestSpace'
            );
        }

        // verify the required parameter 'put_record_assignees_for_guest_space_request' is set
        if ($put_record_assignees_for_guest_space_request === null || (is_array($put_record_assignees_for_guest_space_request) && count($put_record_assignees_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_record_assignees_for_guest_space_request when calling putRecordAssigneesForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/record/assignees.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_record_assignees_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_record_assignees_for_guest_space_request));
            } else {
                $httpBody = $put_record_assignees_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordForGuestSpaceRequest $put_record_for_guest_space_request put_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordForGuestSpaceResponse
     */
    public function putRecordForGuestSpace($guest_space_id, $put_record_for_guest_space_request, string $contentType = self::contentTypes['putRecordForGuestSpace'][0])
    {
        list($response) = $this->putRecordForGuestSpaceWithHttpInfo($guest_space_id, $put_record_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordForGuestSpaceRequest $put_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordForGuestSpaceWithHttpInfo($guest_space_id, $put_record_for_guest_space_request, string $contentType = self::contentTypes['putRecordForGuestSpace'][0])
    {
        $request = $this->putRecordForGuestSpaceRequest($guest_space_id, $put_record_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordForGuestSpaceRequest $put_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordForGuestSpaceAsync($guest_space_id, $put_record_for_guest_space_request, string $contentType = self::contentTypes['putRecordForGuestSpace'][0])
    {
        return $this->putRecordForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_record_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordForGuestSpaceRequest $put_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_record_for_guest_space_request, string $contentType = self::contentTypes['putRecordForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PutRecordForGuestSpaceResponse';
        $request = $this->putRecordForGuestSpaceRequest($guest_space_id, $put_record_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordForGuestSpaceRequest $put_record_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordForGuestSpaceRequest($guest_space_id, $put_record_for_guest_space_request, string $contentType = self::contentTypes['putRecordForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putRecordForGuestSpace'
            );
        }

        // verify the required parameter 'put_record_for_guest_space_request' is set
        if ($put_record_for_guest_space_request === null || (is_array($put_record_for_guest_space_request) && count($put_record_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_record_for_guest_space_request when calling putRecordForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/record.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_record_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_record_for_guest_space_request));
            } else {
                $httpBody = $put_record_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordStatus
     *
     * @param  \Kintone\Model\PutRecordStatusRequest $put_record_status_request put_record_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatus'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordStatusResponse
     */
    public function putRecordStatus($put_record_status_request, string $contentType = self::contentTypes['putRecordStatus'][0])
    {
        list($response) = $this->putRecordStatusWithHttpInfo($put_record_status_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordStatusWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordStatusRequest $put_record_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatus'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordStatusResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordStatusWithHttpInfo($put_record_status_request, string $contentType = self::contentTypes['putRecordStatus'][0])
    {
        $request = $this->putRecordStatusRequest($put_record_status_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordStatusResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordStatusResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordStatusAsync
     *
     * @param  \Kintone\Model\PutRecordStatusRequest $put_record_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordStatusAsync($put_record_status_request, string $contentType = self::contentTypes['putRecordStatus'][0])
    {
        return $this->putRecordStatusAsyncWithHttpInfo($put_record_status_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordStatusAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordStatusRequest $put_record_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordStatusAsyncWithHttpInfo($put_record_status_request, string $contentType = self::contentTypes['putRecordStatus'][0])
    {
        $returnType = '\Kintone\Model\PutRecordStatusResponse';
        $request = $this->putRecordStatusRequest($put_record_status_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordStatus'
     *
     * @param  \Kintone\Model\PutRecordStatusRequest $put_record_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordStatusRequest($put_record_status_request, string $contentType = self::contentTypes['putRecordStatus'][0])
    {

        // verify the required parameter 'put_record_status_request' is set
        if ($put_record_status_request === null || (is_array($put_record_status_request) && count($put_record_status_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_record_status_request when calling putRecordStatus'
            );
        }


        $resourcePath = '/k/v1/record/status.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_record_status_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_record_status_request));
            } else {
                $httpBody = $put_record_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordStatusForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordStatusForGuestSpaceRequest $put_record_status_for_guest_space_request put_record_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordStatusForGuestSpaceResponse
     */
    public function putRecordStatusForGuestSpace($guest_space_id, $put_record_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordStatusForGuestSpace'][0])
    {
        list($response) = $this->putRecordStatusForGuestSpaceWithHttpInfo($guest_space_id, $put_record_status_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordStatusForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordStatusForGuestSpaceRequest $put_record_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordStatusForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordStatusForGuestSpaceWithHttpInfo($guest_space_id, $put_record_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordStatusForGuestSpace'][0])
    {
        $request = $this->putRecordStatusForGuestSpaceRequest($guest_space_id, $put_record_status_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordStatusForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordStatusForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordStatusForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordStatusForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordStatusForGuestSpaceRequest $put_record_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordStatusForGuestSpaceAsync($guest_space_id, $put_record_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordStatusForGuestSpace'][0])
    {
        return $this->putRecordStatusForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_record_status_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordStatusForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordStatusForGuestSpaceRequest $put_record_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordStatusForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_record_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordStatusForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PutRecordStatusForGuestSpaceResponse';
        $request = $this->putRecordStatusForGuestSpaceRequest($guest_space_id, $put_record_status_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordStatusForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordStatusForGuestSpaceRequest $put_record_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordStatusForGuestSpaceRequest($guest_space_id, $put_record_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordStatusForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putRecordStatusForGuestSpace'
            );
        }

        // verify the required parameter 'put_record_status_for_guest_space_request' is set
        if ($put_record_status_for_guest_space_request === null || (is_array($put_record_status_for_guest_space_request) && count($put_record_status_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_record_status_for_guest_space_request when calling putRecordStatusForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/record/status.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_record_status_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_record_status_for_guest_space_request));
            } else {
                $httpBody = $put_record_status_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordsStatus
     *
     * @param  \Kintone\Model\PutRecordsStatusRequest $put_records_status_request put_records_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatus'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordsStatusResponse
     */
    public function putRecordsStatus($put_records_status_request, string $contentType = self::contentTypes['putRecordsStatus'][0])
    {
        list($response) = $this->putRecordsStatusWithHttpInfo($put_records_status_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordsStatusWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordsStatusRequest $put_records_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatus'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordsStatusResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordsStatusWithHttpInfo($put_records_status_request, string $contentType = self::contentTypes['putRecordsStatus'][0])
    {
        $request = $this->putRecordsStatusRequest($put_records_status_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordsStatusResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordsStatusResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordsStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordsStatusAsync
     *
     * @param  \Kintone\Model\PutRecordsStatusRequest $put_records_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordsStatusAsync($put_records_status_request, string $contentType = self::contentTypes['putRecordsStatus'][0])
    {
        return $this->putRecordsStatusAsyncWithHttpInfo($put_records_status_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordsStatusAsyncWithHttpInfo
     *
     * @param  \Kintone\Model\PutRecordsStatusRequest $put_records_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordsStatusAsyncWithHttpInfo($put_records_status_request, string $contentType = self::contentTypes['putRecordsStatus'][0])
    {
        $returnType = '\Kintone\Model\PutRecordsStatusResponse';
        $request = $this->putRecordsStatusRequest($put_records_status_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordsStatus'
     *
     * @param  \Kintone\Model\PutRecordsStatusRequest $put_records_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordsStatusRequest($put_records_status_request, string $contentType = self::contentTypes['putRecordsStatus'][0])
    {

        // verify the required parameter 'put_records_status_request' is set
        if ($put_records_status_request === null || (is_array($put_records_status_request) && count($put_records_status_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_records_status_request when calling putRecordsStatus'
            );
        }


        $resourcePath = '/k/v1/records/status.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_records_status_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_records_status_request));
            } else {
                $httpBody = $put_records_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRecordsStatusForGuestSpace
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsStatusForGuestSpaceRequest $put_records_status_for_guest_space_request put_records_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Kintone\Model\PutRecordsStatusForGuestSpaceResponse
     */
    public function putRecordsStatusForGuestSpace($guest_space_id, $put_records_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordsStatusForGuestSpace'][0])
    {
        list($response) = $this->putRecordsStatusForGuestSpaceWithHttpInfo($guest_space_id, $put_records_status_for_guest_space_request, $contentType);
        return $response;
    }

    /**
     * Operation putRecordsStatusForGuestSpaceWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsStatusForGuestSpaceRequest $put_records_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \Kintone\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Kintone\Model\PutRecordsStatusForGuestSpaceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRecordsStatusForGuestSpaceWithHttpInfo($guest_space_id, $put_records_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordsStatusForGuestSpace'][0])
    {
        $request = $this->putRecordsStatusForGuestSpaceRequest($guest_space_id, $put_records_status_for_guest_space_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Kintone\Model\PutRecordsStatusForGuestSpaceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Kintone\Model\PutRecordsStatusForGuestSpaceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Kintone\Model\PutRecordsStatusForGuestSpaceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putRecordsStatusForGuestSpaceAsync
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsStatusForGuestSpaceRequest $put_records_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordsStatusForGuestSpaceAsync($guest_space_id, $put_records_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordsStatusForGuestSpace'][0])
    {
        return $this->putRecordsStatusForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_records_status_for_guest_space_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRecordsStatusForGuestSpaceAsyncWithHttpInfo
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsStatusForGuestSpaceRequest $put_records_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRecordsStatusForGuestSpaceAsyncWithHttpInfo($guest_space_id, $put_records_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordsStatusForGuestSpace'][0])
    {
        $returnType = '\Kintone\Model\PutRecordsStatusForGuestSpaceResponse';
        $request = $this->putRecordsStatusForGuestSpaceRequest($guest_space_id, $put_records_status_for_guest_space_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRecordsStatusForGuestSpace'
     *
     * @param  int $guest_space_id guest space id (required)
     * @param  \Kintone\Model\PutRecordsStatusForGuestSpaceRequest $put_records_status_for_guest_space_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRecordsStatusForGuestSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRecordsStatusForGuestSpaceRequest($guest_space_id, $put_records_status_for_guest_space_request, string $contentType = self::contentTypes['putRecordsStatusForGuestSpace'][0])
    {

        // verify the required parameter 'guest_space_id' is set
        if ($guest_space_id === null || (is_array($guest_space_id) && count($guest_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guest_space_id when calling putRecordsStatusForGuestSpace'
            );
        }

        // verify the required parameter 'put_records_status_for_guest_space_request' is set
        if ($put_records_status_for_guest_space_request === null || (is_array($put_records_status_for_guest_space_request) && count($put_records_status_for_guest_space_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $put_records_status_for_guest_space_request when calling putRecordsStatusForGuestSpace'
            );
        }


        $resourcePath = '/k/guest/{guestSpaceId}/v1/records/status.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guest_space_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guestSpaceId' . '}',
                ObjectSerializer::toPathValue($guest_space_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($put_records_status_for_guest_space_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($put_records_status_for_guest_space_request));
            } else {
                $httpBody = $put_records_status_for_guest_space_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
