<?php
/**
 * PutPreviewAppReportsForGuestSpaceRequestReportsValue
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Kintone
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * REST API SPEC
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 20250423000000
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Kintone\Model;

use \ArrayAccess;
use \Kintone\ObjectSerializer;

/**
 * PutPreviewAppReportsForGuestSpaceRequestReportsValue Class Doc Comment
 *
 * @category Class
 * @package  Kintone
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class PutPreviewAppReportsForGuestSpaceRequestReportsValue implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'putPreviewAppReportsForGuestSpaceRequest_reports_value';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'aggregations' => '\Kintone\Model\PreviewAppReportsPutReportAggregationsInner[]',
        'chart_type' => 'string',
        'filter_cond' => 'string',
        'groups' => '\Kintone\Model\PreviewAppReportsPutGroup[]',
        'index' => 'int',
        'name' => 'string',
        'periodic_report' => '\Kintone\Model\PreviewAppReportsPutPeriodicReport',
        'sorts' => '\Kintone\Model\PreviewAppReportsPutSort[]',
        'chart_mode' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'aggregations' => null,
        'chart_type' => null,
        'filter_cond' => 'query',
        'groups' => null,
        'index' => 'long',
        'name' => null,
        'periodic_report' => null,
        'sorts' => null,
        'chart_mode' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'aggregations' => false,
        'chart_type' => false,
        'filter_cond' => false,
        'groups' => false,
        'index' => false,
        'name' => false,
        'periodic_report' => false,
        'sorts' => false,
        'chart_mode' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'aggregations' => 'aggregations',
        'chart_type' => 'chartType',
        'filter_cond' => 'filterCond',
        'groups' => 'groups',
        'index' => 'index',
        'name' => 'name',
        'periodic_report' => 'periodicReport',
        'sorts' => 'sorts',
        'chart_mode' => 'chartMode'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'aggregations' => 'setAggregations',
        'chart_type' => 'setChartType',
        'filter_cond' => 'setFilterCond',
        'groups' => 'setGroups',
        'index' => 'setIndex',
        'name' => 'setName',
        'periodic_report' => 'setPeriodicReport',
        'sorts' => 'setSorts',
        'chart_mode' => 'setChartMode'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'aggregations' => 'getAggregations',
        'chart_type' => 'getChartType',
        'filter_cond' => 'getFilterCond',
        'groups' => 'getGroups',
        'index' => 'getIndex',
        'name' => 'getName',
        'periodic_report' => 'getPeriodicReport',
        'sorts' => 'getSorts',
        'chart_mode' => 'getChartMode'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const CHART_TYPE_PIE = 'PIE';
    public const CHART_TYPE_LINE = 'LINE';
    public const CHART_TYPE_SPLINE = 'SPLINE';
    public const CHART_TYPE_TABLE = 'TABLE';
    public const CHART_TYPE_PIVOT_TABLE = 'PIVOT_TABLE';
    public const CHART_TYPE_BAR = 'BAR';
    public const CHART_TYPE_COLUMN = 'COLUMN';
    public const CHART_TYPE_AREA = 'AREA';
    public const CHART_TYPE_SPLINE_AREA = 'SPLINE_AREA';
    public const CHART_MODE_NORMAL = 'NORMAL';
    public const CHART_MODE_STACKED = 'STACKED';
    public const CHART_MODE_PERCENTAGE = 'PERCENTAGE';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getChartTypeAllowableValues()
    {
        return [
            self::CHART_TYPE_PIE,
            self::CHART_TYPE_LINE,
            self::CHART_TYPE_SPLINE,
            self::CHART_TYPE_TABLE,
            self::CHART_TYPE_PIVOT_TABLE,
            self::CHART_TYPE_BAR,
            self::CHART_TYPE_COLUMN,
            self::CHART_TYPE_AREA,
            self::CHART_TYPE_SPLINE_AREA,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getChartModeAllowableValues()
    {
        return [
            self::CHART_MODE_NORMAL,
            self::CHART_MODE_STACKED,
            self::CHART_MODE_PERCENTAGE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('aggregations', $data ?? [], null);
        $this->setIfExists('chart_type', $data ?? [], null);
        $this->setIfExists('filter_cond', $data ?? [], null);
        $this->setIfExists('groups', $data ?? [], null);
        $this->setIfExists('index', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('periodic_report', $data ?? [], null);
        $this->setIfExists('sorts', $data ?? [], null);
        $this->setIfExists('chart_mode', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['chart_type'] === null) {
            $invalidProperties[] = "'chart_type' can't be null";
        }
        $allowedValues = $this->getChartTypeAllowableValues();
        if (!is_null($this->container['chart_type']) && !in_array($this->container['chart_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'chart_type', must be one of '%s'",
                $this->container['chart_type'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['index'] === null) {
            $invalidProperties[] = "'index' can't be null";
        }
        if (!is_null($this->container['name']) && (mb_strlen($this->container['name']) > 64)) {
            $invalidProperties[] = "invalid value for 'name', the character length must be smaller than or equal to 64.";
        }

        if (!is_null($this->container['name']) && (mb_strlen($this->container['name']) < 1)) {
            $invalidProperties[] = "invalid value for 'name', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['chart_mode'] === null) {
            $invalidProperties[] = "'chart_mode' can't be null";
        }
        $allowedValues = $this->getChartModeAllowableValues();
        if (!is_null($this->container['chart_mode']) && !in_array($this->container['chart_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'chart_mode', must be one of '%s'",
                $this->container['chart_mode'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets aggregations
     *
     * @return \Kintone\Model\PreviewAppReportsPutReportAggregationsInner[]|null
     */
    public function getAggregations()
    {
        return $this->container['aggregations'];
    }

    /**
     * Sets aggregations
     *
     * @param \Kintone\Model\PreviewAppReportsPutReportAggregationsInner[]|null $aggregations An array of objects containing the \"Function\" options. The maximum limit is 10 elements in the array.  If the reports.{graphname}.chartType parameter is set to PIVOT_TABLE, only 1 element can be set in the array.  Required when adding a new graph.
     *
     * @return self
     */
    public function setAggregations($aggregations)
    {
        if (is_null($aggregations)) {
            throw new \InvalidArgumentException('non-nullable aggregations cannot be null');
        }
        $this->container['aggregations'] = $aggregations;

        return $this;
    }

    /**
     * Gets chart_type
     *
     * @return string
     */
    public function getChartType()
    {
        return $this->container['chart_type'];
    }

    /**
     * Sets chart_type
     *
     * @param string $chart_type The chart type of the graph. - BAR: Bar chart - COLUMN: Column chart - PIE: Pie chart - LINE: Line chart - PIVOT_TABLE: Pivot Table - TABLE: Table - AREA: Area chart - SPLINE: Spline chart - SPLINE_AREA: Spline area chart  Required when updating an existing graph, or creating a new graph.
     *
     * @return self
     */
    public function setChartType($chart_type)
    {
        if (is_null($chart_type)) {
            throw new \InvalidArgumentException('non-nullable chart_type cannot be null');
        }
        $allowedValues = $this->getChartTypeAllowableValues();
        if (!in_array($chart_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'chart_type', must be one of '%s'",
                    $chart_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['chart_type'] = $chart_type;

        return $this;
    }

    /**
     * Gets filter_cond
     *
     * @return string|null
     */
    public function getFilterCond()
    {
        return $this->container['filter_cond'];
    }

    /**
     * Sets filter_cond
     *
     * @param string|null $filter_cond The record's filter condition in query string format that reflects the \"Filter\" option. If this parameter is ignored for a new graph, it is the same as when \"All records\" is specified. If this parameter is ignored for an existing graph, the filter setting will not be changed. The request will fail if a deleted User, Group, or Organization is specified in the filter condition.
     *
     * @return self
     */
    public function setFilterCond($filter_cond)
    {
        if (is_null($filter_cond)) {
            throw new \InvalidArgumentException('non-nullable filter_cond cannot be null');
        }
        $this->container['filter_cond'] = $filter_cond;

        return $this;
    }

    /**
     * Gets groups
     *
     * @return \Kintone\Model\PreviewAppReportsPutGroup[]|null
     */
    public function getGroups()
    {
        return $this->container['groups'];
    }

    /**
     * Sets groups
     *
     * @param \Kintone\Model\PreviewAppReportsPutGroup[]|null $groups An array of objects containing the \"Group by\" options. The order of the objects are in the order of \"Level 1\", \"Level 2\", and \"Level 3\".  The request will fail if the reports.{graphname}.chartType parameter is set to PIVOT_TABLE and reports.{graphname}.groups has less than one object.  Required when adding a new graph.
     *
     * @return self
     */
    public function setGroups($groups)
    {
        if (is_null($groups)) {
            throw new \InvalidArgumentException('non-nullable groups cannot be null');
        }
        $this->container['groups'] = $groups;

        return $this;
    }

    /**
     * Gets index
     *
     * @return int
     */
    public function getIndex()
    {
        return $this->container['index'];
    }

    /**
     * Sets index
     *
     * @param int $index The order of the graphs. The graph is sorted in ascending order, starting from 0. The request will fail if there are duplicate values.  Required when updating an existing graph, or creating a new graph.
     *
     * @return self
     */
    public function setIndex($index)
    {
        if (is_null($index)) {
            throw new \InvalidArgumentException('non-nullable index cannot be null');
        }
        $this->container['index'] = $index;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name The name of the graph. 1 to 64 characters can be specified.  When adding a new graph, the request will fail if the value of this parameter is not the same as reports.{graphname}.  Required when adding a new graph.
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        if ((mb_strlen($name) > 64)) {
            throw new \InvalidArgumentException('invalid length for $name when calling PutPreviewAppReportsForGuestSpaceRequestReportsValue., must be smaller than or equal to 64.');
        }
        if ((mb_strlen($name) < 1)) {
            throw new \InvalidArgumentException('invalid length for $name when calling PutPreviewAppReportsForGuestSpaceRequestReportsValue., must be bigger than or equal to 1.');
        }

        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets periodic_report
     *
     * @return \Kintone\Model\PreviewAppReportsPutPeriodicReport|null
     */
    public function getPeriodicReport()
    {
        return $this->container['periodic_report'];
    }

    /**
     * Sets periodic_report
     *
     * @param \Kintone\Model\PreviewAppReportsPutPeriodicReport|null $periodic_report periodic_report
     *
     * @return self
     */
    public function setPeriodicReport($periodic_report)
    {
        if (is_null($periodic_report)) {
            throw new \InvalidArgumentException('non-nullable periodic_report cannot be null');
        }
        $this->container['periodic_report'] = $periodic_report;

        return $this;
    }

    /**
     * Gets sorts
     *
     * @return \Kintone\Model\PreviewAppReportsPutSort[]|null
     */
    public function getSorts()
    {
        return $this->container['sorts'];
    }

    /**
     * Sets sorts
     *
     * @param \Kintone\Model\PreviewAppReportsPutSort[]|null $sorts An array of objects containing the \"Sort by\" options. The maximum limit is 3 elements in the array.  Required when adding a new graph.
     *
     * @return self
     */
    public function setSorts($sorts)
    {
        if (is_null($sorts)) {
            throw new \InvalidArgumentException('non-nullable sorts cannot be null');
        }
        $this->container['sorts'] = $sorts;

        return $this;
    }

    /**
     * Gets chart_mode
     *
     * @return string
     */
    public function getChartMode()
    {
        return $this->container['chart_mode'];
    }

    /**
     * Sets chart_mode
     *
     * @param string $chart_mode The display mode of the graph. - NORMAL: Clustered graph or Non-stacked graph - STACKED: Stacked graph - PERCENTAGE: 100% stacked graph  If the reports.{graphname}.chartType parameter is set to BAR or COLUMN, NORMAL refers to \"Clustered graph\" display mode. If the reports.{graphname}.chartType parameter is set to AREA or SPLINE_AREA, NORMAL refers to \"Non-stacked graph\" display mode.  Required when the reports.{graphname}.chartType parameter is set to BAR, COLUMN, AREA, or SPLINE_AREA.
     *
     * @return self
     */
    public function setChartMode($chart_mode)
    {
        if (is_null($chart_mode)) {
            throw new \InvalidArgumentException('non-nullable chart_mode cannot be null');
        }
        $allowedValues = $this->getChartModeAllowableValues();
        if (!in_array($chart_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'chart_mode', must be one of '%s'",
                    $chart_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['chart_mode'] = $chart_mode;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


